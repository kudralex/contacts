import { EllipsisMenu, InitModelOf, Menu, MenuDestinations } from '../index';
export type MenuFilterOptions = {
    onlyVisible?: boolean;
    enableDisableKeyStrokes?: boolean;
    notAllowedTypes?: string | string[];
    defaultMenuTypes?: string | string[];
};
export declare const menus: {
    filterAccordingToSelection(prefix: string, selectionLength: number, menuArr: Menu[], destination: MenuDestinations, options?: MenuFilterOptions): Menu[];
    /**
     * Filters menus that don't match the given types, or in other words: only menus with the given types are returned
     * from this method. The visible state is only checked if the parameter onlyVisible is set to true. Otherwise, invisible items are returned and added to the
     * menu-bar DOM (invisible, however). They may change their visible state later. If there are any types in notAllowedTypes each menu is checked also against
     * these types and if they are matching the menu is filtered.
     */
    filter(menuArr: Menu[], types?: string | string[], options?: MenuFilterOptions): Menu[];
    /**
     * Makes leading, trailing and duplicate separators invisible or reverts the visibility change if needed.
     */
    updateSeparatorVisibility(menuArr: Menu | Menu[]): void;
    checkType(menu: Menu, types: string | string[], defaultMenuTypes?: string | string[]): boolean;
    /** @internal */
    _enableDisableMenuKeyStroke(menu: Menu, activated: boolean, exclude: boolean): void;
    /**
     * Checks the type of menu. Don't use this for menu groups.
     * @internal
     */
    _checkType(menu: Menu, types: string[], defaultMenuTypes?: string | string[]): boolean;
    createEllipsisMenu(options: InitModelOf<EllipsisMenu>): EllipsisMenu;
    moveMenuIntoEllipsis(menu: Menu, ellipsis: EllipsisMenu): void;
    removeMenuFromEllipsis(menu: Menu, $parent?: JQuery): void;
};
//# sourceMappingURL=menus.d.ts.map