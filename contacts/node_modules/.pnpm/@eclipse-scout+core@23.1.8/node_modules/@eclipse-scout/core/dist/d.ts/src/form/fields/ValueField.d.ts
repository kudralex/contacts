/// <reference types="jquery" />
import { AbstractLayout, EnumObject, FormField, InitModelOf, Status, StatusType, ValueFieldEventMap, ValueFieldModel } from '../../index';
export declare class ValueField<TValue extends TModelValue, TModelValue = TValue> extends FormField implements ValueFieldModel<TValue, TModelValue> {
    model: ValueFieldModel<TValue, TModelValue>;
    eventMap: ValueFieldEventMap<TValue>;
    self: ValueField<any>;
    clearable: ValueFieldClearable;
    formatter: ValueFieldFormatter<TValue>;
    hasText: boolean;
    initialValue: TValue;
    invalidValueMessageKey: string;
    parser: ValueFieldParser<TValue>;
    value: TValue;
    validators: ValueFieldValidator<TValue>[];
    protected _updateDisplayTextPending: boolean;
    constructor();
    static Clearable: {
        /**
         * The clear icon is showed when the field has text.
         */
        readonly ALWAYS: "always";
        /**
         * The clear icon will be showed when the field is focused and has text.
         */
        readonly FOCUSED: "focused";
        /**
         * Never show the clear icon.
         */
        readonly NEVER: "never";
    };
    static MenuTypes: {
        readonly Null: "ValueField.Null";
        readonly NotNull: "ValueField.NotNull";
    };
    protected _init(model: InitModelOf<this>): void;
    /**
     * Override this method if you need to influence the value initialization (e.g. do something before the value is initially set)
     */
    protected _initValue(value: TValue): void;
    protected _renderProperties(): void;
    protected _remove(): void;
    /**
     * The default impl. is a NOP, because not every ValueField has a sensible display text.
     */
    protected _renderDisplayText(): void;
    /**
     * The default impl. returns an empty string, because not every ValueField has a sensible display text.
     */
    protected _readDisplayText(): string;
    protected _onClearIconMouseDown(event: JQuery.MouseDownEvent): void;
    protected _onFieldBlur(event: JQuery.BlurEvent): void;
    /**
     * Accepts the current input and writes it to the model.
     *
     * This method is typically called by the {@link _onFieldBlur} function of the field, but may actually be called from anywhere (e.g. button, actions, cell editor, etc.).
     * It is also called by the {@link aboutToBlurByMouseDown} function, which is required because our Ok- and Cancel-buttons are not focusable (thus {@link _onFieldBlur} is
     * never called) but changes in the value-field must be sent to the server anyway when a button is clicked.
     *
     * The default reads the display text using {@link _readDisplayText} and writes it to the model by calling {@link _triggerAcceptInput}.
     * If subclasses don't have a display-text or want to write another state to the server, they may override this method.
     */
    acceptInput(whileTyping?: boolean): JQuery.Promise<void> | void;
    parseAndSetValue(displayText: string): void;
    protected _parsingFailed(displayText: string, error: any): void;
    protected _addParsingFailedErrorStatus(displayText: string, error: any): void;
    protected _createParsingFailedStatus(displayText: string, error: any): Status;
    /**
     * Replaces the existing parser. The parser is called during {@link parseValue}.
     *
     * Remember calling the default parser passed as parameter to the parse function, if needed.
     * @param parser the new parser. If null, the default parser is used.
     *
     * @see ValueFieldModel.parser
     */
    setParser(parser: ValueFieldParser<TValue>): void;
    protected _setParser(parser: ValueFieldParser<TValue>): void;
    /**
     * @returns the parsed value
     * @throws a message, a {@link Status} or an error if the parsing fails
     */
    parseValue(displayText: string): TValue;
    /**
     * @throws a message, a {@link Status} or an error if the parsing fails
     */
    protected _parseValue(displayText: string): TValue;
    protected _checkDisplayTextChanged(displayText: string, whileTyping?: boolean): boolean;
    /**
     * Method invoked upon a mousedown click with this field as the currently focused control, and is invoked just before the mousedown click will be interpreted.
     * However, the mousedown target must not be this control, but any other control instead.
     *
     * The default implementation checks, whether the click occurred outside this control, and if so invokes 'ValueField.acceptInput'.
     *
     * @param target
     *        the DOM target where the mouse down event occurred.
     */
    aboutToBlurByMouseDown(target: Element): void;
    isFocused(): boolean;
    isFocusOnField(target: Element): boolean;
    /** @internal */
    _triggerAcceptInput(whileTyping: boolean): void;
    /** @see ValueFieldModel.displayText */
    setDisplayText(displayText: string): void;
    protected _updateHasText(): void;
    setHasText(hasText: boolean): void;
    protected _renderHasText(): void;
    /** @see ValueFieldModel.clearable */
    setClearable(clearableStyle: ValueFieldClearable): void;
    protected _renderClearable(): void;
    protected _updateClearableStyles(): void;
    isClearable(): boolean;
    /**
     * Clears the display text and the value to null.
     */
    clear(): void;
    protected _clear(): void;
    protected _triggerClear(): void;
    /** @see ValueFieldModel.value */
    setValue(value: TValue | TModelValue): void;
    /**
     * Resets the value to its initial value.
     */
    resetValue(): void;
    /**
     * Default does nothing because the value field does not know which type the concrete field uses.
     * May be overridden to cast the value to the required type.
     * @returns the value with the correct type.
     */
    protected _ensureValue(value: TValue | TModelValue): TValue;
    protected _setValue(value: TValue | TModelValue): void;
    protected _valueEquals(valueA: TValue, valueB: TValue): boolean;
    /**
     * Is called after a value is changed. May be implemented by subclasses. The default does nothing.
     */
    protected _valueChanged(): void;
    protected _getCurrentMenuTypes(): string[];
    /**
     * Validates the value by executing the validators. If a new value is the result, it will be set.
     */
    validate(): void;
    /**
     * @param validator the validator to be added.
     *     A validator is a function that accepts a raw value and either returns the validated value or
     *     throws an Error, a Status or an error message (string) if the value is invalid.
     * @param revalidate True, to revalidate the value, false to just add the validator and do nothing else. Default is true.
     */
    addValidator(validator: ValueFieldValidator<TValue>, revalidate?: boolean): void;
    /**
     * @param validator the validator to be removed
     * @param revalidate True, to revalidate the value, false to just remove the validator and do nothing else. Default is true.
     */
    removeValidator(validator: ValueFieldValidator<TValue>, revalidate?: boolean): void;
    /**
     * Replaces all existing validators with the given one. If you want to add multiple validators, use {@link #addValidator}.
     * <p>
     * Remember calling the default validator which is passed as parameter to the validate function, if needed.
     *
     * @param validator the new validator which replaces every other. If null, the default validator is used.
     *     A validator is a function that accepts a raw value and either returns the validated value or
     *     throws an Error, a Status or an error message (string) if the value is invalid.
     */
    setValidator(validator: ValueFieldValidator<TValue>, revalidate?: boolean): void;
    setValidators(validators: ValueFieldValidator<TValue>[], revalidate?: boolean): void;
    /**
     * @param the value to be validated
     * @returns the validated value
     * @throws a message, a {@link Status} or an error if the validation fails
     */
    validateValue(value: TValue): TValue;
    /**
     * @returns the validated value
     * @throws a message, a {@link Status} or an error if the validation fails
     */
    protected _validateValue(value: TValue): TValue;
    protected _validationFailed(value: TValue, error: any): void;
    protected _ensureValueFailed(value: TModelValue, error: any): void;
    protected _formatRawValue(value: TModelValue): string;
    protected _createValidationFailedStatus(value: TValue | TModelValue, error: any): Status;
    protected _createInvalidValueStatus(statusType: StatusType, value: any, error: any): Status;
    protected _updateDisplayText(value?: TValue): void;
    /**
     * Replaces the existing formatter. The formatter is called during {@link formatValue}.
     *
     * Remember calling the default formatter which is passed as parameter to the format function, if needed.
     * @param formatter the new formatter. If null, the default formatter is used.
     *
     * @see ValueFieldModel.formatter
     */
    setFormatter(formatter: ValueFieldFormatter<TValue>): void;
    protected _setFormatter(formatter: ValueFieldFormatter<TValue>): void;
    /**
     * @returns the formatted display text
     */
    formatValue(value: TValue): string | JQuery.Promise<string>;
    protected _formatValue(value: TValue): string | JQuery.Promise<string>;
    protected _updateTouched(): void;
    addClearIcon($parent?: JQuery): void;
    addContainer($parent: JQuery, cssClass?: string, layout?: AbstractLayout): void;
    addField($field: JQuery): void;
    markAsSaved(): void;
    protected _updateEmpty(): void;
    /**
     * Invokes 'ValueField.aboutToBlurByMouseDown' on the currently active value field.
     * This method has no effect if another element is the focus owner.
     */
    static invokeValueFieldAboutToBlurByMouseDown(target: Element): void;
    /**
     * Invokes 'ValueField.acceptInput' on the currently active value field.
     * This method has no effect if another element is the focus owner.
     */
    static invokeValueFieldAcceptInput(target: Element): void;
    /**
     * Returns the currently active value field, or null if another element is active.
     * Also, if no value field currently owns the focus, its parent is checked to be a value field and is returned accordingly.
     * That is used in DateField.js with multiple input elements.
     */
    protected static _getActiveValueField(target: Element): ValueField<any>;
}
export type ValueFieldClearable = EnumObject<typeof ValueField.Clearable>;
export type ValueFieldMenuTypes = EnumObject<typeof ValueField.MenuTypes>;
export type ValueFieldValidator<TValue> = (value: TValue, defaultValidator?: ValueFieldValidator<TValue>) => TValue;
export type ValueFieldFormatter<TValue> = (value: TValue, defaultFormatter?: ValueFieldFormatter<TValue>) => string | JQuery.Promise<string>;
export type ValueFieldParser<TValue> = (displayText: string, defaultParser?: ValueFieldParser<TValue>) => TValue;
//# sourceMappingURL=ValueField.d.ts.map