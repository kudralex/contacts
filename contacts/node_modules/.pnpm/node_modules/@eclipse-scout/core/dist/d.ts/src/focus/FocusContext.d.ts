/// <reference types="jquery" />
import { FocusManager } from '../index';
import KeyDownEvent = JQuery.KeyDownEvent;
import FocusInEvent = JQuery.FocusInEvent;
import FocusOutEvent = JQuery.FocusOutEvent;
import TriggeredEvent = JQuery.TriggeredEvent;
/**
 * A focus context is associated with a $container, and controls how to focus elements within that $container.
 */
export declare class FocusContext {
    focusManager: FocusManager;
    /** variable to store the last valid focus position; used to restore focus once being re-activated. */
    lastValidFocusedElement: HTMLElement;
    focusedElement: HTMLElement;
    prepared: boolean;
    $container: JQuery;
    /** Notice: every listener is installed on $container and not on $field level, except 'remove' listener because it does not bubble. */
    protected _keyDownListener: (e: KeyDownEvent) => void;
    protected _focusInListener: (e: FocusInEvent) => void;
    protected _focusOutListener: (e: FocusOutEvent) => void;
    protected _unfocusableListener: (e: TriggeredEvent) => void;
    protected _removeListener: (e: TriggeredEvent) => void;
    constructor($container: JQuery, focusManager: FocusManager);
    ready(): void;
    dispose(): void;
    /**
     * Method invoked once a 'keydown' event is fired to control proper tab cycle.
     */
    protected _onKeyDown(event: KeyDownEvent): void;
    /**
     * Method invoked once a 'focusin' event is fired by this context's $container or one of its child controls.
     */
    protected _onFocusIn(event: FocusInEvent): void;
    /**
     * Method invoked once a 'focusout' event is fired by this context's $container or one of its child controls.
     */
    protected _onFocusOut(event: FocusOutEvent): void;
    /**
     * Method invoked once a child element of this context's $container is removed.
     */
    protected _onRemove(event: TriggeredEvent): void;
    /**
     * Function invoked once a child element of this context's $container is hidden or disabled
     * and it cannot have the focus anymore. In that case we need to look for a new focusable
     * element.
     */
    protected _onUnfocusable(event: TriggeredEvent): void;
    /**
     * Focuses the given element if being a child of this context's container and matches the given filter (if provided).
     *
     * @param element
     *        the element to focus, or null to focus the context's first focusable element matching the given filter.
     * @param filter
     *        filter that controls which element should be focused, or null to accept all focusable candidates.
     * @param options prevents scrolling to new focused element (default is false)
     */
    validateAndSetFocus(element?: HTMLElement, filter?: () => boolean, options?: {
        preventScroll?: boolean;
    }): void;
    /**
     * Calls {@link #validateAndSetFocus} with {@link #lastValidFocusedElement}.
     */
    validateFocus(filter?: () => boolean): void;
    /**
     * Restores the focus on the last valid focused element. Does nothing, if there is no last valid focused element.
     */
    restoreFocus(): void;
    /**
     * Focuses the requested element.
     *
     * @param element the element to focus, or null to focus the context's first focusable element matching the given filter.
     * @param options prevents scrolling to new focused element (default is false)
     */
    protected _focus(elementToFocus: HTMLElement, options?: {
        preventScroll?: boolean;
    }): void;
}
//# sourceMappingURL=FocusContext.d.ts.map