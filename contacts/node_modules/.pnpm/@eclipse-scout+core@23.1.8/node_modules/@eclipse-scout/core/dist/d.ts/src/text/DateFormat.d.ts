import { DateFormatPatternDefinition, DateFormatSymbols, Locale } from '../index';
/**
 * Custom JavaScript Date Format
 *
 * Support for formatting and parsing dates based on a pattern string and some locale
 * information from the server model. A subset of the standard Java pattern strings
 * (see SimpleDateFormat) with the most commonly used patterns is supported.
 *
 * This object only operates on the local time zone.
 * <p>
 * locale.dateFormatSymbols contains:
 * <ul>
 * <li>weekdays start with Sunday (starts at 0 and not 1 as it does in java)</li>
 * <li>weekdaysShort start with Sunday (starts at 0 and not 1 as it does in java)</li>
 * <li>months start with January</li>
 * <li>monthsShort start with January<7li>
 * <li>am</li>
 * <li>pm</li>
 *</ul>
 *
 * @see http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html
 */
export declare class DateFormat {
    locale: Locale;
    pattern: string;
    symbols: DateFormatSymbols;
    lenient: boolean;
    /**
     * List of terms, e.g. split up parts of this.pattern. The length of this array is equal
     * to the length of this._formatFunctions, this._parseFunctions and this._analyzeFunctions.
     */
    protected _terms: string[];
    /**
     * List of format function to be called _in that exact order_ to convert this.pattern
     * to a formatted date string (by sequentially replacing all terms with real values).
     */
    protected _formatFunctions: ((formatContext: DateFormatContext) => void)[];
    /**
     * List of parse functions to be called _in that exact order_ to convert an input
     * string to a valid JavaScript Date object. This order matches the recognized terms
     * in the pattern. Unrecognized terms are represented by a "constant" function that
     * matches the string itself (e.g. separator characters or spaces).
     */
    protected _parseFunctions: ((parseContext: DateFormatParseContext) => boolean)[];
    /** Array of arrays, same order as _parseFunctions, but term functions are a list of term functions (to support lenient parsing) */
    protected _analyzeFunctions: ((parseContext: DateFormatParseContext) => boolean)[][];
    protected _patternDefinitions: DateFormatPatternDefinition[];
    protected _patternLibrary: Record<string, DateFormatPatternDefinition[]>;
    constructor(locale: Locale, pattern: string, options?: DateFormatOptions);
    protected _compile(): void;
    /**
     * Returns a format function for constant terms (e.g. all parts of a pattern that don't have a {@link DateFormatPatternDefinition}).
     */
    protected _createConstantStringFormatFunction(term: string): (formatContext: DateFormatContext) => void;
    /**
     * Returns a parse function for constant terms (e.g. all parts of a pattern that don't
     * have a DateFormatPatternDefinition).
     */
    protected _createConstantStringParseFunction(term: string): (parseContext: DateFormatParseContext) => boolean;
    /**
     * Formats the given date according to the date pattern. If the date is missing, the
     * empty string is returned.
     *
     * @param exactLength
     *          May be set to true to force the patterns to use the exact length. For example,
     *          the year pattern 'yyy' would normally format the year using 2 digits. If
     *          the parameter is true, 3 are used. This is mainly useful, when an "analyzed"
     *          date should be formatted again using the "parsedPattern".
     */
    format(date: Date, exactLength?: boolean): string;
    /**
     * Analyzes the given string and returns an information object with all recognized information
     * for the current date format.
     */
    analyze(text: string, startDate?: Date): DateFormatAnalyzeInfo;
    /**
     * Parses the given text with the current date format. If the text does not match exactly
     * with the pattern, "null" is returned. Otherwise, the parsed date is returned.
     *
     * The argument 'startDate' is optional. It may set the date where parsed information should
     * be applied to (e.g. relevant for 2-digit years).
     */
    parse(text: string, startDate?: Date): Date;
    private _dateInfoToDate;
    /**
     * Returns the date where parsed information should be applied to. The given
     * startDate is used when specified, otherwise a new date is created (today).
     */
    protected _prepareStartDate(startDate: Date): Date;
    /**
     * Returns the "format context", an object that is initially filled with the input date and is then
     * passed through the various formatting functions. As the formatting progresses, the format context object
     * is updated accordingly. At the end of the process, the object contains the result.
     */
    protected _createFormatContext(inputDate: Date): DateFormatContext;
    /**
     * Returns the "parse context", an object that is initially filled with the input string and is then
     * passed through the various parsing functions. As the parsing progresses, the parse context object
     * is updated accordingly. At the end of the process, the object contains the result.
     */
    protected _createParseContext(inputText: string): DateFormatParseContext;
    protected _createAnalyzeInfo(inputText: string): DateFormatAnalyzeInfo;
    static ensure(locale: Locale, format: string | DateFormat): DateFormat;
}
export interface DateFormatOptions {
    /**
     * Relevant during analyze(). When this is true (default), terms of the same "pattern type" (e.g. "d" and "dd") will
     * also be considered. Otherwise, analyze() behaves like parse(), i.g. the pattern must match exactly.
     * Example: "2.10" will match the pattern "dd.MM.yyy" when lenient=true. If lenient is false, it won't match.
     */
    lenient?: boolean;
}
export interface DateFormatMatchInfo {
    year?: string;
    month?: string;
    week?: string;
    day?: string;
    weekday?: number;
    hours?: string;
    ampm?: string;
    minutes?: string;
    seconds?: string;
    milliseconds?: string;
    timezone?: string;
}
export interface DateFormatDateInfo {
    year?: number;
    month?: number;
    day?: number;
    hours?: number;
    minutes?: number;
    seconds?: number;
    milliseconds?: number;
    timezone?: number;
}
export interface DateFormatParseContext {
    /**
     * The original input for the parsing. This string will be consumed during the parse process, and will be empty at the end.
     */
    inputString: string;
    /**
     * An object with all numeric date parts that could be parsed from the input string.
     * Unrecognized parts are undefined, all others are converted to numbers.
     * Those values may be directly used in the JavaScript Date() type (month is zero-based!).
     */
    dateInfo: DateFormatDateInfo;
    /**
     * Similar to dateInfo, but the parts are defined as strings as they were parsed from the input.
     * While dateInfo may contain the year 1995, the matchInfo may contain "95". Also note that the month is "one-based", as opposed to dateInfo.month!
     */
    matchInfo: DateFormatMatchInfo;
    /**
     * An object that contains further recognized date parts that are not needed to define the exact time.
     */
    hints: DateFormatHints;
    parsedPattern: string;
    /**
     * A flag that indicates if the "analyze mode" is on. This is true when analyze() was called, and false when parse() was called.
     * It may alter the behavior of the parse functions, i.e. they will not fail in analyze mode when the pattern does not match exactly.
     */
    analyze: boolean;
    /**
     * A date to be used as reference for date calculations. Is used for example when mapping a 2-digit year to a 4-digit year.
     */
    startDate: Date;
}
export interface DateFormatHints {
    am?: boolean;
    pm?: boolean;
    /**
     * number 0-6; 0=sun, 1=mon, etc.
     */
    weekday?: number;
    /**
     * number 1-53
     */
    weekInYear?: number;
}
export interface DateFormatContext {
    /**
     * The date to be formatted.
     */
    inputDate: Date;
    /**
     * The result of the formatting. The string is initially empty. During the format process, the formatted parts will be appended to the string until the final string is complete.
     */
    formattedString: string;
    /**
     * Flag to force the format functions to use the exact length of the accepted term. The default is false, which will use the canonical length.
     * For example, the year pattern 'yyy' will format the year using 2 digits by default. If the parameter is true, 3 are used.
     * This is mainly useful, when an "analyzed" date should be formatted again using the "parsedPattern".
     */
    exactLength: boolean;
}
export interface DateFormatAnalyzeInfo {
    /**
     * The original input for the analysis.
     */
    inputString: string;
    /**
     * An object with all numeric date parts that could be parsed from the input string. Unrecognized parts are undefined, all others are converted to numbers.
     * Those values may be directly used in the JavaScript Date() type (month is zero-based!).
     */
    dateInfo: DateFormatDateInfo;
    /**
     * Similar to dateInfo, but the parts are defined as strings as they were parsed from the input.
     * While dateInfo may contain the year 1995, the matchInfo may contain "95". Also note that the month is "one-based", as opposed to dateInfo.month!
     */
    matchInfo: DateFormatMatchInfo;
    /**
     * An object that contains further recognized date parts that are not needed to define the exact time.
     */
    hints: DateFormatHints;
    /**
     * The pattern that was used to parse the input. This may differ from the date format's pattern.
     * Example: dateFormat="dd.MM.YYYY", inputString="5.7.2015" --> parsedPattern="d.M.yyyy"
     */
    parsedPattern: string;
    /**
     * The pattern that was recognized in the input. Unlike "parsedPattern", this may not be a full pattern.
     * Example: dateFormat="dd.MM.YYYY", inputString="5.7." --> parsedPattern="d.M.yyyy", matchedPattern="d.M."
     */
    matchedPattern: string;
    /**
     * The date that could be predicted from the recognized inputs.
     * If the second method argument 'startDate' is set, this date is used as basis for this predicted date. Otherwise, 'today' is used.
     */
    predictedDate: Date;
    /**
     * Boolean that indicates if analyzing the input was successful (e.g. if the pattern could be parsed and a date could be predicted).
     */
    error: boolean;
}
//# sourceMappingURL=DateFormat.d.ts.map