/// <reference types="jquery" />
import { EventHandler, InitModelOf, ObjectOrModel, Page, PageWithTableModel, Table, TableAllRowsDeletedEvent, TableReloadEvent, TableRow, TableRowActionEvent, TableRowOrderChangedEvent, TableRowsDeletedEvent, TableRowsInsertedEvent, TableRowsUpdatedEvent } from '../../../index';
export declare class PageWithTable extends Page implements PageWithTableModel {
    model: PageWithTableModel;
    alwaysCreateChildPage: boolean;
    protected _tableRowDeleteHandler: EventHandler<TableRowsDeletedEvent | TableAllRowsDeletedEvent>;
    protected _tableRowInsertHandler: EventHandler<TableRowsInsertedEvent>;
    protected _tableRowUpdateHandler: EventHandler<TableRowsUpdatedEvent>;
    protected _tableRowActionHandler: EventHandler<TableRowActionEvent>;
    protected _tableRowOrderChangeHandler: EventHandler<TableRowOrderChangedEvent>;
    protected _tableDataLoadHandler: EventHandler<TableReloadEvent>;
    constructor();
    init(model: InitModelOf<this>): void;
    protected _initDetailTable(table: Table): void;
    protected _destroyDetailTable(table: Table): void;
    protected _onTableRowsDeleted(event: TableRowsDeletedEvent | TableAllRowsDeletedEvent): void;
    /**
     * We must set childNodeIndex on each created childPage because it is required to
     * determine the order of nodes in the tree.
     */
    protected _onTableRowsInserted(event: TableRowsInsertedEvent): void;
    protected _onTableRowsUpdated(event: TableRowsUpdatedEvent): void;
    protected _onTableRowAction(event: TableRowActionEvent): void;
    protected _onTableRowOrderChanged(event: TableRowOrderChangedEvent): void;
    protected _createChildPageInternal(row: TableRow): Page;
    /**
     * Override this method to return a specific Page instance for the given table-row.
     * The default impl. returns null, which means a AutoLeafPageWithNodes instance will be created for the table-row.
     */
    createChildPage(row: TableRow): Page;
    createDefaultChildPage(row: TableRow): Page;
    loadChildren(): JQuery.Promise<any>;
    protected _createSearchFilter(): any;
    /**
     * see Java: AbstractPageWithTable#loadChildren that's where the table is reloaded and the tree is rebuilt, called by AbstractTree#P_UIFacade
     */
    loadTableData(): JQuery.Promise<any>;
    /**
     * Override this method to load table data (rows to be added to table).
     * This is an asynchronous operation working with a Promise. If table data load is successful,
     * <code>_onLoadTableDataDone(data)</code> will be called. If a failure occurs while loading table
     * data, <code>_onLoadTableDataFail(data)</code> will be called.
     * <p>
     * If you want to return static data, you can return a resolvedPromise:
     * <code>return $.resolvedPromise([{...},{...}]);</code>
     *
     * @param searchFilter The search filter as exported by the search form or null.
     */
    protected _loadTableData(searchFilter: any): JQuery.Promise<any>;
    /**
     * This method is called when table data load is successful. It should transform the table data
     * object to table rows.
     *
     * @param tableData data loaded by <code>_loadTableData</code>
     */
    protected _onLoadTableDataDone(tableData: any): void;
    protected _onLoadTableDataFail(error: any): void;
    protected _onLoadTableDataAlways(): void;
    /**
     * This method converts the loaded table data, which can be any object, into table rows.
     * You must override this method unless tableData is already an array of table rows.
     */
    protected _transformTableDataToTableRows(tableData: any): ObjectOrModel<TableRow>[];
}
//# sourceMappingURL=PageWithTable.d.ts.map