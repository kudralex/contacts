import { ButtonTile, ChildModelOf, EnumObject, Event, EventHandler, EventListener, EventMapOf, EventModel, EventSupport, Form, HtmlComponent, InitModelOf, Outline, PageEventMap, PageModel, PropertyChangeEvent, Table, TableRow, TableRowClickEvent, TreeNode } from '../../../index';
/**
 * This class is used differently in online and JS-only case. In the online case we only have instances
 * of Page in an outline. The server sets the property <code>nodeType</code> which is used to distinct
 * between pages with tables and pages with nodes in some cases. In the JS only case, Page is an abstract
 * class and is never instantiated directly, instead we always use subclasses of PageWithTable or PageWithNodes.
 * Implementations of these classes contain code which loads table data or child nodes.
 */
export declare class Page extends TreeNode implements PageModel {
    model: PageModel;
    eventMap: PageEventMap;
    self: Page;
    parent: Outline;
    childNodes: Page[];
    parentNode: Page;
    /**
     * This property is set by the server, see: JsonOutline#putNodeType.
     */
    nodeType: NodeType;
    compactRoot: boolean;
    detailTable: Table;
    detailTableVisible: boolean;
    detailForm: Form;
    detailFormVisible: boolean;
    detailFormVisibleByUi: boolean;
    navigateButtonsVisible: boolean;
    tableStatusVisible: boolean;
    htmlComp: HtmlComponent;
    /**
     * True to select the page linked with the selected row when the row was selected. May be useful on touch devices.
     */
    drillDownOnRowClick: boolean;
    /**
     * The icon id which is used for icons in the tile outline overview.
     */
    overviewIconId: string;
    showTileOverview: boolean;
    row: TableRow;
    tile: ButtonTile;
    events: EventSupport;
    protected _tableFilterHandler: EventHandler<Event<Table>>;
    protected _tableRowClickHandler: EventHandler<TableRowClickEvent>;
    protected _detailTableModel: ChildModelOf<Table>;
    /** @internal */
    _detailFormModel: ChildModelOf<Form>;
    constructor();
    /**
     * This enum defines a node-type. This is basically used for the Scout Classic case where we only have instances
     * of Page, but never instances of PageWithTable or PageWithNodes. The server simply sets a nodeType instead.
     */
    static NodeType: {
        readonly NODES: "nodes";
        readonly TABLE: "table";
    };
    protected _init(model: InitModelOf<this>): void;
    protected static _removePropertyIfLazyLoading(object: PageModel, name: string): any;
    protected _destroy(): void;
    protected _internalInitTable(): void;
    protected _internalInitDetailForm(): void;
    ensureDetailTable(): void;
    /**
     * Creates the detail table
     * @returns the created table or null
     */
    createDetailTable(): Table;
    /**
     * Override this function to create the internal table. Default impl. returns null.
     */
    protected _createDetailTable(): Table;
    ensureDetailForm(): void;
    /**
     * Creates the detail form
     * @returns the created form or null
     */
    createDetailForm(): Form;
    /**
     * Override this function to return a detail form which is displayed in the outline when this page is selected.
     * The default implementation returns null.
     */
    protected _createDetailForm(): Form;
    /**
     * Override this function to initialize the internal detail form.
     * @param form the form to initialize.
     */
    protected _initDetailForm(form: Form): void;
    /**
     * Override this function to destroy the internal (detail) form.
     * @param form the form to destroy.
     */
    protected _destroyDetailForm(form: Form): void;
    /**
     * Override this function to initialize the internal (detail) table.
     * Default impl. delegates filter events to the outline mediator.
     * @param table The table to initialize.
     */
    protected _initDetailTable(table: Table): void;
    /**
     * Override this function to destroy the internal (detail) table.
     * @param table the table to destroy.
     */
    protected _destroyDetailTable(table: Table): void;
    /** @internal */
    _decorate(): void;
    activate(): void;
    deactivate(): void;
    /**
     * @returns the tree / outline / parent instance. it's all the same,
     *     but it's more intuitive to work with the 'outline' when we deal with pages.
     */
    getOutline(): Outline;
    /**
     * @returns an array of pages linked with the given rows.
     *   The order of the returned pages will be the same as the order of the rows.
     */
    pagesForTableRows(rows: TableRow[]): Page[];
    pageForTableRow(row: TableRow): Page;
    /**
     * @param form The new form
     */
    setDetailForm(form: Form): void;
    protected _setDetailForm(form: Form): void;
    /**
     * @param table The new table
     */
    setDetailTable(table: Table): void;
    protected _setDetailTable(table: Table): void;
    /**
     * Updates relevant properties from the pages linked with the given rows using the method updatePageFromTableRow and returns the pages.
     *
     * @returns pages linked with the given rows.
     */
    updatePagesFromTableRows(rows: TableRow[]): Page[];
    /**
     * Updates relevant properties (text, enabled, htmlEnabled) from the page linked with the given row.
     *
     * @returns page linked with the given row.
     */
    updatePageFromTableRow(row: TableRow): Page;
    /**
     * This function creates the text property of this page. The default implementation returns the
     * text from the first cell of the given row. It's allowed to ignore the given row entirely, when you override
     * this function.
     */
    computeTextForRow(row: TableRow): string;
    /**
     * @returns a page parameter object used to pass to newly created child pages. Sets the parent
     *     to our outline instance and adds optional other properties. Typically, you'll pass an
     *     object (entity-key or arbitrary data) to a child page.
     */
    protected _pageParam<T extends object>(paramProperties: T): T;
    reloadPage(): void;
    linkWithRow(row: TableRow): void;
    unlinkWithRow(row: TableRow): void;
    protected _onTableFilter(event: Event<Table>): void;
    protected _onTableRowClick(event: TableRowClickEvent): void;
    /**
     * Triggers a property change for a single property.
     */
    triggerPropertyChange<T>(propertyName: string, oldValue: T, newValue: T): PropertyChangeEvent<T, this>;
    trigger<K extends string & keyof EventMapOf<Page>>(type: K, eventOrModel?: Event<Page> | EventModel<EventMapOf<Page>[K]>): EventMapOf<Page>[K];
    one<K extends string & keyof EventMapOf<this>>(type: K, handler: EventHandler<EventMapOf<this>[K] & Event<this>>): void;
    on<K extends string & keyof EventMapOf<this>>(type: K, handler: EventHandler<(EventMapOf<this>)[K] & Event<this>>): EventListener;
    off<K extends string & keyof EventMapOf<this>>(type: K, handler?: EventHandler<EventMapOf<this>[K]>): void;
}
export type NodeType = EnumObject<typeof Page.NodeType>;
//# sourceMappingURL=Page.d.ts.map