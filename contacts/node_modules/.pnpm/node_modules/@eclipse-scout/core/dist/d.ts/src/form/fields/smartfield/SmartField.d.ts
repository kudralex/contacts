/// <reference types="jquery" />
import { CellEditorPopup, CellEditorRenderedOptions, ColumnDescriptor, EnumObject, InitModelOf, KeyStrokeContext, LoadingSupport, LookupCall, LookupCallOrModel, LookupResult, LookupRow, MaxLengthHandler, ProposalChooserActiveFilterSelectedEvent, ProposalChooserLookupRowSelectedEvent, SmartFieldEventMap, SmartFieldModel, SmartFieldPopup, SmartFieldTouchPopup, Status, ValueField } from '../../../index';
export declare class SmartField<TValue> extends ValueField<TValue> implements SmartFieldModel<TValue> {
    model: SmartFieldModel<TValue>;
    eventMap: SmartFieldEventMap<TValue>;
    self: SmartField<any>;
    popup: SmartFieldTouchPopup<TValue> | SmartFieldPopup<TValue>;
    lookupCall: LookupCall<TValue>;
    codeType: string;
    lookupRow: LookupRow<TValue>;
    browseHierarchy: boolean;
    browseMaxRowCount: number;
    browseAutoExpandAll: boolean;
    browseLoadIncremental: boolean;
    searchRequired: boolean;
    activeFilterEnabled: boolean;
    activeFilter: SmartFieldActiveFilter;
    activeFilterLabels: string[];
    columnDescriptors: ColumnDescriptor[];
    displayStyle: SmartFieldDisplayStyle;
    touchMode: boolean;
    embedded: boolean;
    lookupStatus: Status;
    /** used to detect if the proposal chooser contains the results of the latest lookup, or an out-dated result. */
    lookupSeqNo: number;
    /** only when the result is up-to-date, we can use the selected lookup row */
    initActiveFilter: SmartFieldActiveFilter;
    maxLength: number;
    maxLengthHandler: MaxLengthHandler;
    /**
     * should only be accessed on the original widget since the adapter accesses it
     * @internal
     */
    _currentLookupCall: LookupCall<TValue>;
    protected _pendingLookup: number;
    protected _pendingOpenPopup: boolean;
    protected _tabPrevented: {
        shiftKey: boolean;
    };
    /** used to detect whether the last thing the user did was typing (a proposal) or something else, like selecting a proposal row */
    protected _userWasTyping: boolean;
    /** used to prevent multiple execution of blur/acceptInput */
    protected _acceptInputEnabled: boolean;
    protected _acceptInputDeferred: JQuery.Deferred<any>;
    /** used to store the error state 'not unique' which must not be showed while typing, but when the field loses focus */
    protected _notUnique: boolean;
    protected _lastSearchText: string;
    protected _cellEditorPopup: CellEditorPopup<TValue>;
    protected _lockLookupRow: boolean;
    constructor();
    static DisplayStyle: {
        readonly DEFAULT: "default";
        readonly DROPDOWN: "dropdown";
    };
    static ErrorCode: {
        readonly NOT_UNIQUE: 1;
        readonly NO_RESULTS: 2;
        readonly NO_DATA: 3;
        readonly SEARCH_REQUIRED: 4;
    };
    static DEBOUNCE_DELAY: number;
    static DEFAULT_BROWSE_MAX_COUNT: number;
    static ActiveFilter: {
        readonly UNDEFINED: "UNDEFINED";
        readonly FALSE: "FALSE";
        readonly TRUE: "TRUE";
    };
    /**
     * @see "IContentAssistField#getActiveFilterLabels()" - should have the same order.
     */
    static ACTIVE_FILTER_VALUES: readonly ["UNDEFINED", "FALSE", "TRUE"];
    protected _init(model: InitModelOf<this>): void;
    /**
     * Initializes lookup call and code type before calling set value.
     * This cannot be done in _init because the value field would call _setValue first
     */
    protected _initValue(value: TValue): void;
    markAsSaved(): void;
    resetValue(): void;
    protected _createKeyStrokeContext(): KeyStrokeContext;
    protected _initKeyStrokeContext(): void;
    protected _render(): void;
    protected _renderProperties(): void;
    protected _renderGridData(): void;
    protected _renderGridDataHints(): void;
    cssClassName(): string;
    protected _readSearchText(): string;
    _readDisplayText(): string;
    protected _renderDisplayText(): void;
    protected _prepareDisplayText(): string;
    /**
     * Accepts the selected lookup row and sets its id as value.
     * This function is called on blur, by a keystroke or programmatically at any time.
     *
     * @param sync optional boolean value (default: false), when set to true acceptInput is not allowed to start an asynchronous lookup for text search
     */
    acceptInput(sync?: boolean): JQuery.Promise<void> | void;
    /**
     * This function is used to determine if the currently selected lookup row can be
     * used when acceptInput is called. Basically we don't want to use the row in case
     * the result is out-dated.
     */
    protected _getSelectedLookupRow(searchTextChanged: boolean): LookupRow<TValue>;
    protected _checkSearchTextChanged(searchText: string): boolean;
    protected _searchTextEquals(searchText: string, lastSearchText: string): boolean;
    protected _clearPendingLookup(): void;
    /**
     * This function is intended to be overridden. Proposal field has another behavior than the smart field.
     *
     * @param sync optional boolean value (default: false), when set to true acceptInput is not allowed to start an asynchronous lookup for text search
     */
    protected _acceptInput(sync: boolean, searchText: string, searchTextEmpty: boolean, searchTextChanged: boolean, selectedLookupRow: LookupRow<TValue>): JQuery.Promise<void> | void;
    /**
     * Required for multiline smart-field. Only use first line of search text for accept by text.
     * Note: for the regular lookup by text, we use the readDisplayText() function which always
     * returns a single line. But in acceptInput we need the full search text (=display text + additional
     * lines) in order to check whether or not the display text has changed, compared to the current
     * lookup row. That's why we must extract the first line here.
     */
    protected _firstTextLine(text: string): string;
    /**
     * This function is intended to be overridden. Proposal field has another behavior than the smart field.
     *
     * @param sync when set to true it's not allowed to start an asynchronous lookup to search by text, the
     *     current search text is discarded. The flag is set to true in case we click on another field, where
     *     we must make sure the order of (browser) events is not changed by the lookup that would return _after_
     *     the events for the clicked field are handled.
     */
    protected _acceptByText(sync: boolean, searchText: string): void;
    protected _acceptByTextSync(searchText: string): void;
    protected _acceptByTextAsync(searchText: string): void;
    protected _inputAccepted(triggerEvent?: boolean, acceptByLookupRow?: boolean): void;
    protected _focusNextTabbable(): void;
    protected _acceptByTextDone(result: SmartFieldLookupResult<TValue>): void;
    /**
     * Extends the properties 'uniqueMatch' and 'numLookupRows' on the given result object.
     * The implementation is different depending on the browseHierarchy property.
     */
    protected _extendResult(result: SmartFieldLookupResult<TValue>): void;
    protected _acceptInputFail(result: SmartFieldLookupResult<TValue>): void;
    lookupByRec(rec: TValue): JQuery.Promise<SmartFieldLookupResult<TValue>>;
    /**
     * Validates the given lookup row is enabled and matches the current activeFilter settings.
     */
    protected _isLookupRowActive(lookupRow: LookupRow<TValue>): boolean;
    protected _renderEnabled(): void;
    setMaxLength(maxLength: number): void;
    protected _renderMaxLength(): void;
    setLookupCall(lookupCall: LookupCallOrModel<TValue>): void;
    protected _setLookupCall(lookupCall: LookupCallOrModel<TValue>): void;
    protected _setCodeType(codeType: string): void;
    protected _formatValue(value: TValue): string | JQuery.Promise<string>;
    protected _lookupByKeyDone(result: SmartFieldLookupResult<TValue>): string;
    /**
     * This function is called when we need to format a display text from a given lookup
     * row. By default the property 'text' is used for that purpose. Override this function
     * if you need to format different properties from the lookupRow.
     */
    protected _formatLookupRow(lookupRow: LookupRow<TValue>): string;
    /**
     * @param browse whether or not the lookup call should execute getAll() or getByText() with the current display text.
     *     if browse is undefined, browse is set to true automatically if search text is empty
     */
    openPopup(browse?: boolean): JQuery.Promise<any>;
    protected _hasUiError(codes?: SmartFieldErrorCode | SmartFieldErrorCode[]): boolean;
    /**
     * @param browse [boolean] optional, whether to perform a lookupByAll (=browse) or a lookupByText.
     *        By default the param is set to <code>true</code> if the search-text is not empty
     * @param searchText [String] optional, when not set the search-text from the smart-field is used
     * @param searchAlways [boolean] optional, only used when browse=false. When set to true the search
     *        is always performed, event when the search-text has not changed. By default the param is
     *        set to <code>false</code>.
     */
    protected _lookupByTextOrAll(browse?: boolean, searchText?: string, searchAlways?: boolean): JQuery.Promise<any>;
    /**
     * Returns the text used to store the 'last search-text'. The implementation differs between SmartField and ProposalField.
     */
    protected _getLastSearchText(): string;
    protected _lookupByTextOrAllDone(result: SmartFieldLookupResult<TValue>): void;
    protected _ensurePopup(result: SmartFieldLookupResult<TValue>, status?: Status): void;
    protected _handleException(result: SmartFieldLookupResult<TValue>): boolean;
    protected _handleEmptyResult(): void;
    protected _renderPopup(result: SmartFieldLookupResult<TValue>, status: Status): void;
    closePopup(): void;
    /**
     * Calls acceptInput if mouse down happens outside the field or popup
     */
    aboutToBlurByMouseDown(target: Element): void;
    protected _onFieldMouseDown(event: JQuery.MouseDownEvent): void;
    activate(onField?: boolean): void;
    protected _onIconMouseDown(event: JQuery.MouseDownEvent): void;
    protected _onClearIconMouseDown(event: JQuery.MouseDownEvent): void;
    protected _clear(): void;
    togglePopup(): void;
    protected _onFieldBlur(event: JQuery.BlurEvent): void;
    /**
     * @returns true if the field is either 'embedded' or in 'touchMode'.
     */
    isTouchable(): boolean;
    protected _onFieldKeyUp(event: JQuery.KeyUpEvent): void;
    protected _handleInput(): void;
    isPopupOpen(): boolean;
    protected _onFieldKeyDown(event: JQuery.KeyDownEvent): void;
    protected _onFieldInput(): void;
    protected _updateUserWasTyping(event: JQuery.KeyDownEvent): void;
    protected _isNavigationKey(event: JQuery.KeyDownEvent | JQuery.KeyUpEvent): boolean;
    protected _handleEnterKey(event: JQuery.KeyDownEvent): void;
    protected _isFunctionKey(event: JQuery.KeyDownEvent | JQuery.KeyUpEvent): boolean;
    protected _onLookupRowSelected(event: ProposalChooserLookupRowSelectedEvent<TValue>): void;
    /**
     * When the user changes the active-filter we must always perform a new search. When the user has typed a searchText
     * we must perform a lookupByText. When the searchText is empty or different from the text of the selected lookup-row
     * we are in browse mode where we use the default given by the 'searchRequired' property. See: #237229.
     */
    protected _onActiveFilterSelected(event: ProposalChooserActiveFilterSelectedEvent<TValue>): void;
    /**
     * @param browseMaxRowCount - a positive number, _not_ null or undefined!
     */
    setBrowseMaxRowCount(browseMaxRowCount: number): void;
    protected _syncBrowseMaxRowCountWithLookupCall(): void;
    setBrowseAutoExpandAll(browseAutoExpandAll: boolean): void;
    setBrowseLoadIncremental(browseLoadIncremental: boolean): void;
    setActiveFilter(activeFilter: SmartFieldActiveFilter): void;
    setActiveFilterEnabled(activeFilterEnabled: boolean): void;
    setInitActiveFilter(initActiveFilter: SmartFieldActiveFilter): void;
    setSearchRequired(searchRequired: boolean): void;
    /**
     * A wrapper function around lookup calls used to display the state in the UI.
     */
    protected _executeLookup(lookupCall: LookupCall<TValue>, abortExisting?: boolean): JQuery.Promise<SmartFieldLookupResult<TValue>>;
    /**
     * Reset error status NO_RESULTS when a lookup is performed, otherwise it would interfere with the
     * temporary lookupStatus and we'd see an out-dated error-status message while the user is typing.
     */
    protected _clearNoResultsErrorStatus(): void;
    /**
     * Returns true if the smart-field lookup returns a lot of rows. In that case
     * the proposal chooser must create a table with virtual scrolling, which means
     * only the rows visible in the UI are rendered in the DOM. By default we render
     * all rows, since this avoids problems with layout-invalidation with rows
     * that have a bitmap-image (PNG) which is loaded asynchronously.
     */
    virtual(): boolean;
    isDropdown(): boolean;
    protected _setLookupRow(lookupRow: LookupRow<TValue>): void;
    setLookupRow(lookupRow: LookupRow<TValue>): void;
    setDisplayText(displayText: string): void;
    resetDisplayText(): void;
    /**
     * This method is very similar to setDisplayText(), but does _not_ check for equality with
     * the current value. The property is always set and (if the field is rendered) the given
     * display text is always rendered. This is important when resetting the display text,
     * because the visible text in the input field may differ from the "displayText" property
     * value. If setDisplayText() was used, the visible text would not always be reset.
     */
    protected _setAndRenderDisplayText(displayText: string): void;
    protected _getValueFromLookupRow(lookupRow: LookupRow<TValue>): TValue;
    protected _setValue(value: TValue): void;
    /**
     * Sub-classes like the proposal field may override this function to implement a different behavior.
     */
    protected _checkResetLookupRow(value: TValue): boolean;
    /**
     * This function may be overridden to return another value than this.value.
     * For instance the proposal field doesn't use the value but the key from the
     * lookup row for comparison.
     *
     * @returns the value used to find the selected element in a proposal chooser.
     */
    getValueForSelection(): TValue;
    protected _showSelection(): boolean;
    /**
     * override to ensure dropdown fields and touch mode smart fields does not have a clear icon.
     */
    isClearable(): boolean;
    protected _triggerLookupCallDone(result: SmartFieldLookupResult<TValue>): SmartFieldLookupResult<TValue>;
    protected _triggerAcceptInputFail(): void;
    /** @internal */
    _triggerAcceptInput(acceptByLookupRow?: boolean, failure?: boolean): void;
    protected _triggerAcceptByText(searchText: string): void;
    /**
     * Function invoked if being rendered within a cell-editor (mode='scout.FormField.Mode.CELLEDITOR'), and once the editor finished its rendering.
     */
    onCellEditorRendered(options: CellEditorRenderedOptions<TValue>): void;
    additionalLines(): string[];
    protected _createLoadingSupport(): LoadingSupport;
    protected _isInitialShowStatus(): boolean;
    /**
     * In touch mode, we must close the cell editor popup explicitly, because the touch-popup and its glasspane
     * prevents the cell editor popup from receiving mouse down events.
     */
    acceptInputFromField(otherField: SmartField<TValue>): void;
    /**
     * This function is overridden by ProposalField because it has a different behavior than the smart-field.
     */
    protected _copyValuesFromField(otherField: SmartField<TValue>): void;
    protected _setNotUniqueError(searchText: string): void;
    protected _hasNotUniqueError(): boolean;
    protected _errorStatus(): Status;
    setLookupStatus(lookupStatus: Status): void;
    clearErrorStatus(): void;
    protected _clearLookupStatus(): void;
    /**
     * Checks if there is a lookup status that needs to be set as error status
     * before we leave the smart-field. The lookup status is set to null, because
     * it is a temporary state that is only important while the user executes a lookup.
     */
    protected _flushLookupStatus(): void;
    requestInput(): void;
}
export type SmartFieldDisplayStyle = EnumObject<typeof SmartField.DisplayStyle>;
export type SmartFieldActiveFilter = EnumObject<typeof SmartField.ActiveFilter>;
export type SmartFieldErrorCode = EnumObject<typeof SmartField.ErrorCode>;
export interface SmartFieldLookupResult<Key> extends LookupResult<Key> {
    appendResult?: boolean;
    /**
     * Used to track if a result is outdated.
     */
    seqNo?: number;
    /**
     * Number of 'relevant' lookupRows, i.e. number of lookupRows for a non hierarchical lookupCall and number of leafs for a hierarchical one
     */
    numLookupRows?: number;
    /**
     * only 'relevant' lookupRow if numLookupRows === 1
     */
    uniqueMatch?: LookupRow<Key>;
}
//# sourceMappingURL=SmartField.d.ts.map