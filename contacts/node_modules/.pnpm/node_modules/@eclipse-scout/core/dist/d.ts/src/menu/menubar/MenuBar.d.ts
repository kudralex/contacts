import { EllipsisMenu, EnumObject, Event, EventHandler, InitModelOf, KeyStroke, KeyStrokeContext, Menu, MenuBarBox, MenuBarEventMap, MenuBarModel, MenuFilter, MenuOrder, ObjectOrChildModel, OrderedMenuItems, PropertyChangeEvent, TooltipPosition, Widget } from '../../index';
export type MenuBarEllipsisPosition = EnumObject<typeof MenuBar.EllipsisPosition>;
export type MenuBarPosition = EnumObject<typeof MenuBar.Position>;
export declare class MenuBar extends Widget implements MenuBarModel {
    model: MenuBarModel;
    eventMap: MenuBarEventMap;
    self: MenuBar;
    menuSorter: MenuOrder & {
        menuBar?: MenuBar;
    };
    menuFilter: MenuFilter;
    position: MenuBarPosition;
    tabbable: boolean;
    menuboxLeft: MenuBarBox;
    menuboxRight: MenuBarBox;
    menuItems: Menu[];
    orderedMenuItems: OrderedMenuItems;
    defaultMenu: Menu;
    ellipsisPosition: MenuBarEllipsisPosition;
    hiddenByUi: boolean;
    tabbableMenu: Menu;
    protected _menuItemPropertyChangeHandler: EventHandler<PropertyChangeEvent>;
    protected _focusHandler: EventHandler<Event<Menu>>;
    protected _ellipsis: EllipsisMenu;
    constructor();
    static EllipsisPosition: {
        readonly LEFT: "left";
        readonly RIGHT: "right";
    };
    static Position: {
        readonly TOP: "top";
        readonly BOTTOM: "bottom";
    };
    protected _init(options: InitModelOf<this>): void;
    protected _destroy(): void;
    protected _createKeyStrokeContext(): KeyStrokeContext;
    protected _initKeyStrokeContext(): void;
    protected _render(): void;
    protected _renderProperties(): void;
    setPosition(position: MenuBarPosition): void;
    protected _setPosition(position: MenuBarPosition): void;
    protected _renderPosition(): void;
    protected _oppositePosition(): TooltipPosition;
    setEllipsisPosition(ellipsisPosition: MenuBarEllipsisPosition): void;
    /**
     * Set the filter of the menu bar to all the menu items.
     */
    protected _setChildMenuFilters(): void;
    /**
     * This function can be called multiple times. The function attaches the menu handlers only if they are not yet added.
     */
    protected _attachMenuHandlers(): void;
    protected _detachMenuHandlers(): void;
    setMenuItems(menuOrModels: ObjectOrChildModel<Menu> | ObjectOrChildModel<Menu>[]): void;
    protected _setMenuItems(menuItems: Menu[], rightFirst?: boolean): void;
    protected _renderMenuItems(): void;
    protected _removeMenuItems(): void;
    protected _createOrderedMenus(menuItems: Menu[]): OrderedMenuItems;
    protected _getFirstStackableIndexPosition(menuList: Menu[]): number;
    protected _updateTabbableMenu(): void;
    setTabbableMenu(menu: Menu): void;
    /**
     * Sets the property hiddenByUi. This does not automatically update the visibility of the menus.
     * We assume that {@link updateVisibility} is called later anyway.
     * @internal
     */
    setHiddenByUi(hiddenByUi: boolean): void;
    updateVisibility(): void;
    /**
     * First rendered item that is enabled and reacts to ENTER keystroke shall be marked as 'defaultMenu'
     *
     * @param updateTabbableMenu if true (default), the "tabbable menu" is updated at the end of this method.
     */
    updateDefaultMenu(updateTabbableMenu?: boolean): void;
    protected _isDefaultKeyStroke(keyStroke: KeyStroke): boolean;
    setDefaultMenu(defaultMenu: Menu): void;
    protected _setDefaultMenu(defaultMenu: Menu): void;
    /**
     * Add class 'left-of-button' to every menu item which is on the left of a button
     */
    updateLeftOfButtonMarker(): void;
    protected _updateLeftOfButtonMarker(items: Menu[]): void;
    protected _onMenuItemPropertyChange(event: PropertyChangeEvent): void;
    protected _onMenuItemFocus(event: Event<Menu>): void;
    reorderMenus(rightFirst?: boolean): void;
    allMenusAsFlatList(): Menu[];
}
//# sourceMappingURL=MenuBar.d.ts.map