/// <reference types="jquery" />
import { Action, ContextMenuPopup, DesktopPopupOpenEvent, DoubleClickSupport, DragAndDropHandler, DropType, EnumObject, EventHandler, Filter, FilterOrFunction, FilterResult, FilterSupport, InitModelOf, KeyStrokeContext, Menu, MenuBar, MenuDestinations, MenuFilter, ObjectOrModel, Range, ScrollDirection, ScrollToOptions, TreeBreadcrumbFilter, TreeEventMap, TreeModel, TreeNode, TreeNodeModel, UpdateFilteredElementsOptions, Widget } from '../index';
export declare class Tree extends Widget implements TreeModel {
    model: TreeModel;
    eventMap: TreeEventMap;
    self: Tree;
    toggleBreadcrumbStyleEnabled: boolean;
    breadcrumbTogglingThreshold: number;
    autoCheckChildren: boolean;
    checkable: boolean;
    checkableStyle: TreeCheckableStyle;
    displayStyle: TreeDisplayStyle;
    dropType: DropType;
    dropMaximumSize: number;
    lazyExpandingEnabled: boolean;
    menus: Menu[];
    contextMenu: ContextMenuPopup;
    menuBar: MenuBar;
    keyStrokes: Action[];
    multiCheck: boolean;
    nodes: TreeNode[];
    /** all nodes by id */
    nodesMap: Record<string, TreeNode>;
    nodePaddingLevelCheckable: number;
    nodePaddingLevelNotCheckable: number;
    nodePaddingLevelDiffParentHasIcon: number;
    nodePaddingLeft: number;
    /** is read from CSS */
    nodeCheckBoxPaddingLeft: number;
    nodeControlPaddingLeft: number;
    /** is read from CSS */
    nodePaddingLevel: number;
    scrollToSelection: boolean;
    /** Only necessary for breadcrumb mode */
    scrollTopHistory: number[];
    selectedNodes: TreeNode[];
    /** The previously selected node, relevant for breadcrumb in compact mode */
    prevSelectedNode: TreeNode;
    filters: Filter<TreeNode>[];
    textFilterEnabled: boolean;
    filterSupport: FilterSupport<TreeNode>;
    filteredElementsDirty: boolean;
    filterAnimated: boolean;
    rebuildSuppressed: boolean;
    breadcrumbFilter: TreeBreadcrumbFilter;
    dragAndDropHandler: DragAndDropHandler;
    /**
     * performance optimization: E.g. rather than iterating over the whole tree when unchecking all nodes,
     * we explicitly keep track of nodes to uncheck (useful e.g. for single-check mode in very large trees).
     */
    checkedNodes: TreeNode[];
    groupedNodes: Record<string, boolean>;
    visibleNodesFlat: TreeNode[];
    visibleNodesMap: Record<string, boolean>;
    viewRangeRendered: Range;
    viewRangeDirty: boolean;
    viewRangeSize: number;
    startAnimationFunc: () => void;
    runningAnimations: number;
    runningAnimationsFinishFunc: () => void;
    nodeHeight: number;
    nodeWidth: number;
    maxNodeWidth: number;
    nodeWidthDirty: boolean;
    requestFocusOnNodeControlMouseDown: boolean;
    initialTraversing: boolean;
    $data: JQuery;
    $fillBefore: JQuery;
    $fillAfter: JQuery;
    /** may be used by subclasses to set additional CSS classes */
    protected _additionalContainerClasses: string;
    protected _renderViewportBlocked: boolean;
    protected _doubleClickSupport: DoubleClickSupport;
    /** used by _renderExpansion() */
    protected _$animationWrapper: JQuery;
    protected _$expandAnimationWrappers: JQuery[];
    protected _filterMenusHandler: MenuFilter;
    protected _popupOpenHandler: EventHandler<DesktopPopupOpenEvent>;
    /** contains all parents of a selected node, the selected node and the first level children */
    protected _inSelectionPathList: Record<string, boolean>;
    protected _scrollDirections: ScrollDirection;
    protected _changeNodeTaskScheduled: boolean;
    protected _$mouseDownNode: JQuery;
    constructor();
    static DisplayStyle: {
        readonly DEFAULT: "default";
        readonly BREADCRUMB: "breadcrumb";
    };
    static CheckableStyle: {
        /**
         * Node check is only possible by checking the checkbox.
         */
        readonly CHECKBOX: "checkbox";
        /**
         * Node check is possible by clicking anywhere on the node.
         */
        readonly CHECKBOX_TREE_NODE: "checkbox_tree_node";
    };
    static MenuTypes: {
        readonly EmptySpace: "Tree.EmptySpace";
        readonly SingleSelection: "Tree.SingleSelection";
        readonly MultiSelection: "Tree.MultiSelection";
        readonly Header: "Tree.Header";
    };
    /**
     * Used to calculate the view range size. See {@link calculateViewRangeSize}.
     */
    static VIEW_RANGE_DIVISOR: number;
    protected _init(model: InitModelOf<this>): void;
    /**
     * Initialize nodes, applies filters and updates flat list
     */
    protected _initNodes(nodes: TreeNode[], parentNode?: TreeNode): void;
    /**
     * Iterates through the given array and converts node-models to instances of TreeNode (or a subclass).
     * If the array element is already a TreeNode the function leaves the element untouched. This function also
     * ensures that the attribute childNodeIndex is set. By default, we use the order of the nodes array as index
     * but only if childNodeIndex is undefined.
     */
    ensureTreeNodes(nodes: ObjectOrModel<TreeNode>[]): void;
    protected _createTreeNode(nodeModel?: TreeNodeModel): TreeNode;
    protected _createKeyStrokeContext(): KeyStrokeContext;
    protected _initKeyStrokeContext(): void;
    protected _initTreeKeyStrokeContext(): void;
    protected _setMenus(argMenus: Menu[]): void;
    protected _updateMenuBar(): void;
    protected _setKeyStrokes(keyStrokes: Action[]): void;
    protected _resetTreeNode(node: TreeNode, parentNode: TreeNode): void;
    isSelectedNode(node: TreeNode): boolean;
    protected _updateSelectionPath(): void;
    protected _initTreeNode(node: TreeNode, parentNode: TreeNode): void;
    /**
     * Override this function if you want a custom node init before filtering.
     * The default implementation does nothing.
     */
    protected _initTreeNodeInternal(node: TreeNode, parentNode: TreeNode): void;
    protected _destroy(): void;
    protected _destroyTreeNode(node: TreeNode): void;
    protected _onNodeDeleted(node: TreeNode): void;
    /**
     * pre-order (top-down) traversal of the tree-nodes of this tree.
     *
     * If func returns true the children of the visited node are not visited.
     */
    visitNodes(func: (node: TreeNode, parentNode?: TreeNode) => boolean | void, parentNode?: TreeNode): void;
    protected _render(): void;
    protected _renderData(): void;
    protected _renderProperties(): void;
    protected _postRender(): void;
    protected _remove(): void;
    isHorizontalScrollingEnabled(): boolean;
    isTreeNodeCheckEnabled(): boolean;
    protected _onScroll(event: JQuery.ScrollEvent): void;
    setScrollTop(scrollTop: number): void;
    /** @internal */
    _renderScrollTop(): void;
    get$Scrollable(): JQuery;
    /** @internal */
    _renderViewport(): void;
    protected _calculateCurrentViewRange(): Range;
    protected _rerenderViewport(): void;
    protected _removeRenderedNodes(): void;
    protected _renderViewRangeForNode(node: TreeNode): void;
    protected _renderNodesInRange(range: Range): void;
    ensureRangeVisible(range: Range): number;
    /** @internal */
    _renderFiller(): void;
    protected _calculateFillerDimension(range: Range): {
        width: number;
        height: number;
    };
    protected _removeNodesInRange(range: Range): void;
    /**
     * Just removes the node, does NOT adjust this.viewRangeRendered
     */
    protected _removeNode(node: TreeNode): void;
    /**
     * Renders the rows visible in the viewport and removes the other rows
     */
    protected _renderViewRange(viewRange: Range): void;
    protected _postRenderViewRange(): void;
    protected _visibleNodesInViewRange(): TreeNode[];
    protected _updateDomNodeWidth(): void;
    protected _cleanupNodes($nodes: JQuery): void;
    /**
     * Returns the TreeNode which is at position scrollTop.
     */
    protected _nodeAtScrollTop(scrollTop: number): TreeNode;
    protected _heightForNode(node: TreeNode): number;
    protected _widthForNode(node: TreeNode): number;
    /**
     * Returns a range of size this.viewRangeSize. Start of range is nodeIndex - viewRangeSize / 4.
     * -> 1/4 of the nodes are before the viewport 2/4 in the viewport 1/4 after the viewport,
     * assuming viewRangeSize is 2*number of possible nodes in the viewport (see calculateViewRangeSize).
     */
    protected _calculateViewRangeForNode(node: TreeNode): Range;
    /**
     * Calculates the optimal view range size (number of nodes to be rendered).
     * It uses the default node height to estimate how many nodes fit in the view port.
     * The view range size is this value * 2.
     * <p>
     * Note: the value calculated by this function is important for calculating the
     * 'insertBatch'. When the value becomes smaller than 4 ({@link Tree.VIEW_RANGE_DIVISOR}) this
     * will cause errors on inserting nodes at the right position. See #262890.
     */
    calculateViewRangeSize(): number;
    setViewRangeSize(viewRangeSize: number): void;
    protected _updateNodeDimensions(): void;
    /**
     * Updates the node heights for every visible node and clears the height of the others
     */
    updateNodeHeights(): void;
    removeAllNodes(): void;
    /**
     * @param parentNode
     *          Optional. If provided, this node's state will be updated (e.g. it will be collapsed
     *          if it does no longer have child nodes). Can also be an array, in which case all of
     *          those nodes are updated.
     */
    protected _removeNodes(nodes: TreeNode[], parentNode?: TreeNode | TreeNode[]): void;
    protected _renderNode(node: TreeNode): JQuery;
    protected _removeMenus(): void;
    protected _filterMenus(argMenus: Menu[], destination: MenuDestinations, onlyVisible?: boolean, enableDisableKeyStrokes?: boolean): Menu[];
    protected _renderEnabled(): void;
    protected _renderDisabledStyle(): void;
    setCheckable(checkable: boolean): void;
    protected _setCheckable(checkable: boolean): void;
    protected _updateNodePaddingLevel(): void;
    setCheckableStyle(checkableStyle: TreeCheckableStyle): void;
    protected _renderCheckable(): void;
    protected _renderDisplayStyle(): void;
    protected _renderExpansion(node: TreeNode, options?: TreeRenderExpansionOptions): void;
    protected _renderSelection(): void;
    protected _renderCheckableStyle(): void;
    protected _highlightPrevSelectedNode(): void;
    protected _removeSelection(): void;
    protected _removeNodeSelection(node: TreeNode): void;
    setDropType(dropType: DropType): void;
    protected _renderDropType(): void;
    setDropMaximumSize(dropMaximumSize: number): void;
    protected _installOrUninstallDragAndDropHandler(): void;
    protected _updateMarkChildrenChecked(node: TreeNode, init: boolean, checked: boolean, checkChildrenChecked?: boolean): void;
    protected _installNodeTooltipSupport(): void;
    protected _uninstallNodeTooltipSupport(): void;
    protected _nodeTooltipText($node: JQuery): string;
    protected _isTruncatedNodeTooltipEnabled(): boolean;
    setDisplayStyle(displayStyle: TreeDisplayStyle): void;
    protected _setDisplayStyle(displayStyle: TreeDisplayStyle): void;
    protected _updateNodePaddingsLeft($nodesToUpdate?: JQuery): void;
    setBreadcrumbStyleActive(active: boolean): void;
    isNodeInBreadcrumbVisible(node: TreeNode): boolean;
    isBreadcrumbStyleActive(): boolean;
    setToggleBreadcrumbStyleEnabled(enabled: boolean): void;
    setBreadcrumbTogglingThreshold(width: number): void;
    expandNode(node: TreeNode, opts?: TreeNodeExpandOptions): void;
    collapseNode(node: TreeNode, opts?: TreeNodeExpandOptions): void;
    collapseAll(): void;
    setNodeExpanded(node: TreeNode, expanded: boolean, opts?: TreeNodeExpandOptions): void;
    setNodeExpandedRecursive(nodes: TreeNode[], expanded: boolean, opts?: TreeNodeExpandOptions): void;
    protected _rebuildParent(node: TreeNode, opts: TreeNodeExpandOptions): void;
    protected _removeChildrenFromFlatList(parentNode: TreeNode, animatedRemove: boolean): TreeNode[];
    protected _removeFromFlatList(node: TreeNode, animatedRemove: boolean): void;
    protected _addToVisibleFlatList(node: TreeNode, renderingAnimated: boolean): void;
    protected _addChildrenToFlatList(parentNode: TreeNode, parentIndex: number, animatedRendering: boolean, insertBatch?: InsertBatch, forceFilter?: boolean): number | InsertBatch;
    /**
     * Checks if the given node is expanded, and if that's the case determine the insert index of the node and add its children to the flat list.
     *
     * @param indexOffset either 0 or 1, offset is added to the insert index
     */
    protected _addChildrenToFlatListIfExpanded(indexOffset: number, node: TreeNode, insertIndex: number, animatedRendering: boolean, insertBatch: InsertBatch, forceFilter: boolean): InsertBatch;
    protected _showNodes(insertBatch: InsertBatch): boolean;
    /**
     * This function tries to find the correct insert position within the flat list for the given node.
     * The function must consider the order of child nodes in the original tree structure and then check
     * where in the flat list this position is.
     */
    protected _findInsertPositionInFlatList(node: TreeNode): number;
    protected _findPositionInFlatList(node: TreeNode): number;
    /**
     * Checks whether the given checkNode belongs to the same subtree (or is) the given node.
     * The function goes up all parentNodes of the checkNode.
     *
     * @param node which is used to for the subtree comparison
     * @param checkNode node which is checked against the given node
     */
    protected _isInSameSubTree(node: TreeNode, checkNode: TreeNode): boolean;
    /**
     * Returns true if the given node is a child of one of the selected nodes.
     * The functions goes up the parent node hierarchy.
     *
     * @param node to check
     */
    isChildOfSelectedNodes(node: TreeNode): boolean;
    /**
     * Info: the object created here is a bit weird: the array 'insertNodes' is used as function arguments to the Array#splice function at some point.
     * The signature of that function is: array.splice(index, deleteCount[, element1[,  element2 [, ...]]])
     * So the first two elements are numbers and all the following elements are TreeNodes or Pages.
     */
    newInsertBatch(insertIndex: number): InsertBatch;
    checkAndHandleBatchAnimationWrapper(parentNode: TreeNode, animatedRendering: boolean, insertBatch: InsertBatch): void;
    checkAndHandleBatch(insertBatch: InsertBatch, parentNode: TreeNode, animatedRendering: boolean): InsertBatch;
    insertBatchInVisibleNodes(insertBatch: InsertBatch, showNodes: boolean, animate: boolean): void;
    protected _addToVisibleFlatListNoCheck(node: TreeNode, insertIndex: number, animatedRendering: boolean): void;
    scrollTo(node: TreeNode, options?: ScrollToOptions | string): void;
    revealSelection(): void;
    ensureExpansionVisible(node: TreeNode): void;
    deselectAll(): void;
    selectNode(node: TreeNode, debounceSend?: boolean): void;
    selectNodes(nodes: TreeNode | TreeNode[], debounceSend?: boolean): void;
    protected _rememberScrollTopBeforeSelection(): void;
    protected _updateScrollTopAfterSelection(): void;
    protected _setSelectedNodes(nodes: TreeNode[], debounceSend?: boolean): void;
    /**
     * This method is overridden by subclasses of Tree. The default impl. does nothing.
     */
    protected _nodesSelectedInternal(nodes: TreeNode[]): void;
    deselectNode(node: TreeNode): void;
    /**
     * @param nodes the nodes to deselect
     * @param options.collectChildren true to add the selected children to the list of nodes to deselect
     */
    deselectNodes(nodes: TreeNode | TreeNode[], options?: {
        collectChildren?: boolean;
    }): void;
    isNodeSelected(node: TreeNode): boolean;
    protected _computeNodePaddingLeft(node: TreeNode): number;
    /** @internal */
    _computeNodeControlPaddingLeft(node: TreeNode): number;
    protected _computeNodePaddingLeftForLevel(node: TreeNode): number;
    /**
     * Reads the paddings from CSS and stores them in nodePaddingLeft and nodeControlPaddingLeft
     */
    protected _computeNodePaddings(): void;
    protected _expandAllParentNodes(node: TreeNode): void;
    protected _updateChildNodeIndex(nodes: TreeNode[], startIndex?: number): void;
    insertNode(node: ObjectOrModel<TreeNode>, parentNode?: TreeNode): void;
    insertNodes(nodes: ObjectOrModel<TreeNode> | ObjectOrModel<TreeNode>[], parentNode?: TreeNode): void;
    updateNode(node: ObjectOrModel<TreeNode>): void;
    updateNodes(nodes: ObjectOrModel<TreeNode> | ObjectOrModel<TreeNode>[]): void;
    /**
     * Called by _onNodesUpdated for every updated node. The function is expected to apply
     * all updated properties from the updatedNode to the oldNode. May be overridden by
     * subclasses so update their specific node properties.
     *
     * @param oldNode
     *          The target node to be updated
     * @param updatedNode
     *          The new node with potentially updated properties. Default values are already applied!
     * @returns
     *          true if at least one property has changed, false otherwise. This value is used to
     *          determine if the node has to be rendered again.
     */
    protected _applyUpdatedNodeProperties(oldNode: TreeNode, updatedNode: ObjectOrModel<TreeNode>): boolean;
    deleteNode(node: TreeNode, parentNode?: TreeNode): void;
    deleteAllNodes(): void;
    deleteNodes(nodes: TreeNode | TreeNode[], parentNode?: TreeNode): void;
    protected _collectNodesIfDescendants(nodes: TreeNode[], nodesToCheck: TreeNode[]): TreeNode[];
    deleteAllChildNodes(parentNode?: TreeNode): void;
    updateNodeOrder(childNodes: TreeNode | TreeNode[], parentNode?: TreeNode): void;
    checkNode(node: TreeNode, checked?: boolean, options?: TreeNodeCheckOptions): void;
    checkNodes(nodes: TreeNode | TreeNode[], options?: TreeNodeCheckOptions): void;
    uncheckNode(node: TreeNode, options?: TreeNodeUncheckOptions): void;
    /**
     * @param nodes the nodes to uncheck
     */
    uncheckNodes(nodes: TreeNode[], options?: TreeNodeUncheckOptions): void;
    protected _triggerNodesSelected(debounce?: boolean): void;
    protected _showContextMenu(event: JQuery.ContextMenuEvent): void;
    /** @internal */
    _onNodeMouseDown(event: JQuery.MouseDownEvent): boolean;
    /** @internal */
    _onNodeMouseUp(event: JQuery.MouseUpEvent): boolean;
    protected _isCheckboxClicked(event: JQuery.MouseDownEvent): boolean;
    protected _updateItemPath(selectionChanged: boolean, ultimate?: TreeNode): void;
    protected _isGroupingEnd(node: TreeNode): boolean;
    /**
     * @returns the first selected node or null when no node is selected.
     */
    selectedNode(): TreeNode;
    $selectedNodes(): JQuery;
    $nodes(): JQuery;
    /**
     * @param filter The filters to add.
     * @param applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.
     */
    addFilter(filter: FilterOrFunction<TreeNode> | FilterOrFunction<TreeNode>[], applyFilter?: boolean): void;
    /**
     * @param filter The filters to remove.
     * @param applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.
     */
    removeFilter(filter: FilterOrFunction<TreeNode> | FilterOrFunction<TreeNode>[], applyFilter?: boolean): void;
    /**
     * @param filters The new filters.
     * @param applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.
     */
    setFilters(filters: FilterOrFunction<TreeNode> | FilterOrFunction<TreeNode>[], applyFilter?: boolean): void;
    filter(): void;
    protected _filter(): TreeFilterResult;
    updateFilteredElements(result: TreeFilterResult, opts: UpdateFilteredElementsOptions): void;
    filterVisibleNodes(animated?: boolean): void;
    protected _nodesFiltered(hiddenNodes: TreeNode[]): void;
    applyFiltersForNode(node: TreeNode, applyNewHiddenShownNodes?: boolean, animated?: boolean): TreeFilterResult;
    protected _applyFiltersForNodeRec(node: TreeNode, recursive: boolean, animated?: boolean): TreeFilterResult;
    /**
     * @returns true if node state has changed, false if not
     */
    protected _applyFiltersForNode(node: TreeNode): boolean;
    protected _createFilterSupport(): FilterSupport<TreeNode>;
    setTextFilterEnabled(textFilterEnabled: boolean): void;
    isTextFilterFieldVisible(): boolean;
    protected _renderTextFilterEnabled(): void;
    /**
     * Just insert node in DOM. NO check if in viewRange
     */
    protected _insertNodesInDOM(nodes: TreeNode[], indexHint?: number): void;
    protected _installNodes(nodes: TreeNode[]): void;
    /**
     * Attaches node to DOM, if it is visible and in view range
     * */
    protected _ensureNodeInDOM(node: TreeNode, useAnimation: boolean, indexHint: number): void;
    protected _insertNodeInDOMAtPlace(node: TreeNode, index: number): void;
    showNode(node: TreeNode, useAnimation: boolean, indexHint: number): void;
    hideNode(node: TreeNode, useAnimation: boolean, suppressDetachHandling?: boolean): void;
    nodesToIds(nodes: TreeNode[]): string[];
    nodesByIds(ids: string[]): TreeNode[];
    nodeById(id: string): TreeNode;
    /**
     * Checks whether the given node is contained in the tree. Uses the id of the node for the lookup.
     */
    hasNode(node: TreeNode): boolean;
    protected _onNodeDoubleClick(event: JQuery.DoubleClickEvent): void;
    doNodeAction(node: TreeNode, expanded: boolean): void;
    protected _onNodeControlMouseDown(event: JQuery.MouseDownEvent): boolean;
    protected _onNodeControlMouseUp(event: JQuery.MouseUpEvent): boolean;
    protected _onNodeControlDoubleClick(event: JQuery.DoubleClickEvent): boolean;
    protected _onContextMenu(event: JQuery.ContextMenuEvent): void;
    changeNode(node: TreeNode): void;
    protected _onDesktopPopupOpen(event: DesktopPopupOpenEvent): void;
    updateScrollbars(): void;
    static collectSubtree($rootNode: JQuery, includeRootNodeInResult?: boolean): JQuery;
    /**
     * pre-order (top-down) traversal of the tree-nodes provided.<br>
     * if func returns true the children of the visited node are not visited.
     */
    static visitNodes(func: (node: TreeNode, parentNode?: TreeNode) => boolean | void, nodes: TreeNode[], parentNode?: TreeNode): void;
}
export type TreeDisplayStyle = EnumObject<typeof Tree.DisplayStyle>;
export type TreeCheckableStyle = EnumObject<typeof Tree.CheckableStyle>;
export type TreeMenuTypes = EnumObject<typeof Tree.MenuTypes>;
export type TreeNodeExpandOptions = {
    /**
     * Default is derived from {@link TreeNode.expandedLazy} and {@link TreeNode.lazyExpandingEnabled} if the node is expanded and false otherwise.
     */
    lazy?: boolean;
    /**
     * Default is true
     */
    renderAnimated?: boolean;
    /**
     * Default is false
     */
    collapseChildNodes?: boolean;
    /**
     * Default is true
     */
    renderExpansion?: boolean;
};
export type TreeRenderExpansionOptions = {
    /**
     * Default is false
     */
    expandLazyChanged?: boolean;
    /**
     * Default is false
     */
    expansionChanged?: boolean;
};
export type TreeNodeCheckOptions = {
    /**
     * Default is true
     */
    checked?: boolean;
    /**
     * Default is true
     */
    checkOnlyEnabled?: boolean;
    /**
     * Default is {@link Tree.autoCheckChildren}
     */
    checkChildren?: boolean;
    /**
     * Specifies if a 'nodesChecked' event should be triggered. Default is true.
     */
    triggerNodesChecked?: boolean;
};
export type TreeNodeUncheckOptions = TreeNodeCheckOptions & {
    /**
     * Default is false.
     */
    checked?: boolean;
    /**
     * true to add the checked children to the list of nodes to uncheck. Default is false.
     */
    collectChildren?: boolean;
};
export type TreeFilterResult = FilterResult<TreeNode>;
export type InsertBatch = {
    /**
     * second element is always 0 (used as argument for deleteCount in Array#splice)
     */
    insertNodes: (number | TreeNode)[];
    $animationWrapper: JQuery;
    lastBatchInsertIndex(): number;
    nextBatchInsertIndex(): number;
    isEmpty(): boolean;
    length(): number;
    insertAt(): number;
    setInsertAt(insertAt: number): any;
    containsNode(node: TreeNode): boolean;
    animationCompleteFunc?(): void;
};
//# sourceMappingURL=Tree.d.ts.map