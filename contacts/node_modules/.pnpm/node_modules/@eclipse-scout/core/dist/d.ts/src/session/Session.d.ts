/// <reference types="jquery" />
import { AjaxCall, AjaxCallModel, BackgroundJobPollingSupport, BusyIndicator, Desktop, Event, EventEmitter, FocusManager, InitModelOf, JsonErrorResponse, KeyStrokeManager, LayoutValidator, Locale, LocaleModel, LogLevel, ModelAdapter, ModelAdapterLike, ObjectWithType, Reconnector, RemoteEvent, ResponseQueue, SessionEventMap, SessionModel, SomeRequired, StatusSeverity, TextMap, URL, UserAgent, Widget } from '../index';
import ErrorTextStatus = JQuery.Ajax.ErrorTextStatus;
export declare class Session extends EventEmitter implements SessionModel, ModelAdapterLike, ObjectWithType {
    model: SessionModel;
    initModel: SomeRequired<this['model'], '$entryPoint'>;
    eventMap: SessionEventMap;
    self: Session;
    objectType: string;
    partId: string;
    url: URL;
    userAgent: UserAgent;
    locale: Locale;
    textMap: TextMap;
    /** true after desktop has been completely rendered */
    ready: boolean;
    /** true when 'beforeOnload' event has been triggered */
    unloading: boolean;
    /** true after unload event has been received from the window */
    unloaded: boolean;
    loggedOut: boolean;
    inspector: boolean;
    persistent: boolean;
    offline: boolean;
    inDevelopmentMode: boolean;
    desktop: Desktop;
    layoutValidator: LayoutValidator;
    focusManager: FocusManager;
    keyStrokeManager: KeyStrokeManager;
    /** assigned by server on session startup (OWASP recommendation, see https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern). */
    uiSessionId: string;
    clientSessionId: string;
    forceNewClientSession: boolean;
    remoteUrl: string;
    unloadUrl: string;
    modelAdapterRegistry: Record<string, ModelAdapterLike>;
    ajaxCalls: AjaxCall[];
    asyncEvents: RemoteEvent[];
    currentEvent: RemoteEvent;
    responseQueue: ResponseQueue;
    requestsPendingCounter: number;
    suppressErrors: boolean;
    /** ms */
    requestTimeoutCancel: number;
    /** ms, depends on polling interval, will therefore be initialized on startup */
    requestTimeoutPoll: number;
    /** ms */
    requestTimeoutPing: number;
    backgroundJobPollingSupport: BackgroundJobPollingSupport;
    reconnector: Reconnector;
    processingEvents: boolean;
    /** This property is enabled by URL parameter &adapterExportEnabled=1. Default is false */
    adapterExportEnabled: boolean;
    requestSequenceNo: number;
    ajaxCallOptions: AjaxCallModel;
    rootAdapter: ModelAdapter;
    root: Widget;
    widget: Widget;
    $entryPoint: JQuery;
    protected _adapterDataCache: Record<string, AdapterData>;
    protected _busy: boolean;
    protected _busyIndicator: BusyIndicator;
    protected _busyIndicatorTimeoutId: number;
    protected _deferredEventTypes: string[];
    protected _deferred: JQuery.Deferred<string[], never, never>;
    protected _fatalMessagesOnScreen: Record<string, boolean>;
    protected _retryRequest: RemoteRequest;
    protected _queuedRequest: RemoteRequest;
    protected _asyncDelay: number;
    protected _sendTimeoutId: number;
    constructor();
    static JsonResponseError: {
        readonly STARTUP_FAILED: 5;
        readonly SESSION_TIMEOUT: 10;
        readonly UI_PROCESSING: 20;
        readonly UNSAFE_UPLOAD: 30;
        readonly REJECTED_UPLOAD: 31;
        readonly VERSION_MISMATCH: 40;
    };
    static EMPTY_UPLOAD_FILENAME: string;
    init(model: InitModelOf<this>): void;
    protected _throwError(message?: string): void;
    unregisterModelAdapter(modelAdapter: ModelAdapter): void;
    registerModelAdapter(modelAdapter: ModelAdapter): void;
    getModelAdapter(id: string): ModelAdapterLike;
    getWidget(adapterId: string): Widget;
    getOrCreateWidget(adapterId: string, parent: Widget, strict?: boolean): Widget;
    createModelAdapter(adapterData: AdapterData): ModelAdapter;
    /**
     * Sends the request asynchronously and processes the response later.<br>
     * Furthermore, the request is sent delayed. If send is called multiple times
     * during the same user interaction, the events are collected and sent in one
     * request at the end of the user interaction
     */
    sendEvent(event: RemoteEvent, delay?: number): void;
    protected _sendStartupRequest(): JQuery.Promise<any>;
    /**
     * Creates an object to send to the server as "startupParams".
     *
     * Default params:
     * "url":
     *   browser URL (without query and hash part)
     * "geolocationServiceAvailable":
     *   true if browser supports geolocation services
     *
     * Additionally, all query parameters from the URL are put in the resulting object.
     */
    protected _createSessionStartupParams(): SessionStartupParams;
    protected _processStartupResponse(data: SessionStartupResponse): void;
    protected _storeClientSessionIdInStorage(clientSessionId: string): void;
    protected _getClientSessionIdFromStorage(): string;
    render(renderFunc: () => void): void;
    protected _sendUnloadRequest(): void;
    protected _sendNow(): void;
    protected _coalesceEvents(previousEvents: RemoteEvent[], event: RemoteEvent): RemoteEvent[];
    protected _sendRequest(request: RemoteRequest): void;
    protected _handleSendWhenOffline(request: RemoteRequest): void;
    defaultAjaxOptions(request: RemoteRequest): JQuery.AjaxSettings;
    protected _decorateUrl(url: string, request: RemoteRequest): string;
    protected _getRequestName(request: RemoteRequest, defaultName: string): string;
    protected _requestToJson(request: RemoteRequest): string;
    protected _callAjax(callOptions?: AjaxCallModel): JQuery.Promise<RemoteResponse>;
    protected _performUserAjaxRequest(ajaxOptions: JQuery.AjaxSettings, busyHandling: boolean, request?: RemoteRequest): void;
    registerAjaxCall(ajaxCall: AjaxCall): void;
    unregisterAjaxCall(ajaxCall: AjaxCall): void;
    interruptAllAjaxCalls(): void;
    abortAllAjaxCalls(): void;
    /**
     * (Re-)starts background job polling when not started yet or when an error occurred while polling.
     * In the latter case, polling is resumed when a user-initiated request has been successful.
     */
    protected _resumeBackgroundJobPolling(): void;
    /**
     * Polls the results of jobs running in the background. Note: we cannot use the _sendRequest method here
     * since we don't want any busy handling in case of background jobs. The request may take a while, since
     * the server doesn't return until either a time-out occurs or there's something in the response when
     * a model job is done and no request initiated by a user is running.
     */
    protected _pollForBackgroundJobs(): void;
    /**
     * Do NOT call this method directly, always use the response queue:
     * ```
     *   session.responseQueue.process(data);
     * ```
     * Otherwise, the response queue's expected sequence number will get out of sync.
     */
    processJsonResponseInternal(data: RemoteResponse): boolean;
    protected _processSuccessResponse(message: RemoteResponse): void;
    protected _copyAdapterData(adapterData: Record<string, AdapterData>): void;
    protected _processErrorResponse(jqXHR: JQuery.jqXHR, textStatus: ErrorTextStatus, errorThrown: string, request: RemoteRequest): void;
    protected _processErrorJsonResponse(jsonError: JsonErrorResponse): boolean;
    protected _fireRequestFinished(message: RemoteResponse): void;
    /**
     * Shows a UI-only message box.
     *
     * @param options
     *          Options for the message box, see MessageBox
     * @param errorCode
     *          If defined, a second call to this method with the same errorCode will
     *          do nothing. Can be used to prevent double messages for the same error.
     */
    showFatalMessage(options: FatalMessageOptions, errorCode?: string): void;
    isFatalMessageShown(): boolean;
    uploadFiles(target: {
        id: string;
    }, files: BlobWithName[], uploadProperties?: Record<string, string | Blob>, maxTotalSize?: number, allowedTypes?: string[]): boolean;
    goOffline(): void;
    goOnline(): void;
    onReconnecting(): void;
    onReconnectingSucceeded(): void;
    onReconnectingFailed(): void;
    listen(): JQuery.Deferred<string[], never, never>;
    /**
     * Executes the given callback when pending requests are finished, or immediately if there are no requests pending.
     * @param func callback function
     * @param vararg arguments to pass to the callback function
     */
    onRequestsDone(func: (...args: any[]) => void, ...vararg: any[]): void;
    /**
     * Executes the given callback when all events of the current response are processed. Executes it immediately if no events are being processed.
     * @param func callback function
     * @param vararg arguments to pass to the callback function
     */
    onEventsProcessed(func: (...args: any[]) => void, ...vararg: any[]): void;
    areEventsQueued(): boolean;
    areBusyIndicatedEventsQueued(): boolean;
    areResponsesQueued(): boolean;
    areRequestsPending(): boolean;
    setRequestPending(pending: boolean): void;
    setBusy(busy: boolean): void;
    protected _renderBusy(): void;
    protected _removeBusy(): void;
    protected _onCancelProcessing(event: Event): void;
    protected _sendCancelRequest(): void;
    /**
     * Sends a request containing the log message for logging purpose.
     * The request is sent immediately (does not await pending requests).
     * @param message the log message
     * @param level the log level used to log the message. Default is {@link LogLevel.ERROR}.
     */
    sendLogRequest(message: string, level?: LogLevel): void;
    /** @internal */
    _newRequest(requestData?: RemoteRequestData): RemoteRequest;
    protected _processEvents(events: RemoteEvent[]): void;
    start(): JQuery.Promise<any>;
    onModelEvent(event: RemoteEvent): void;
    resetEventFilters(): void;
    destroy(): void;
    exportAdapterData(adapterData: AdapterData): AdapterData;
    protected _onLocaleChanged(event: RemoteEvent & {
        locale?: LocaleModel;
        textMap?: Record<string, string>;
    }): void;
    /**
     * @param locale the new locale
     * @param textMap the new textMap. If not defined, the corresponding textMap for the new locale is used.
     */
    switchLocale(locale: Locale, textMap?: TextMap): void;
    /** @internal */
    _renderDesktop(): void;
    protected _onLogout(event: RemoteEvent & {
        redirectUrl?: string;
    }): void;
    logout(logoutUrl: string): void;
    protected _onDisposeAdapter(event: RemoteEvent & {
        adapter?: string;
    }): void;
    protected _onReloadPage(event: RemoteEvent): void;
    protected _onWindowBeforeUnload(evt: BeforeUnloadEvent): void;
    protected _onWindowUnload(): void;
    /**
     * Returns the adapter-data sent with the JSON response from the adapter-data cache. Note that this operation
     * removes the requested element from the cache, thus you cannot request the same ID twice. Typically, once
     * you've requested an element from this cache an adapter for that ID is created and stored in the adapter
     * registry which too exists on this session object.
     */
    protected _getAdapterData(id: string): AdapterData;
    getAdapterData(id: string): AdapterData;
    /**
     * Returns the text for the given key.
     *
     * @param textKey key to look up the text
     * @param args texts to replace the placeholders specified by {0}, {1}, etc.
     */
    text(textKey: string, ...args: any[]): string;
    /**
     * Returns the text for the given key.
     *
     * @param textKey key to look up the text
     * @param defaultValue the text to return if the key has not been found.
     * @param args texts to replace the placeholders specified by {0}, {1}, etc.
     */
    optText(textKey: string, defaultValue?: string, ...args: string[]): string;
    textExists(textKey: string): boolean;
}
export interface RemoteRequest extends RemoteRequestData {
    uiSessionId: string;
    '#'?: number;
    '#ACK'?: number;
    event: {
        target: string;
        type: string;
    };
}
export interface RemoteRequestData {
    events?: RemoteEvent[];
    clientSessionId?: string;
    syncResponseQueue?: boolean;
    log?: boolean;
    message?: string;
    level?: LogLevel;
    startup?: boolean;
    unload?: boolean;
    cancel?: boolean;
    ping?: boolean;
    partId?: string;
    version?: string;
    userAgent?: UserAgent;
    sessionStartupParams?: SessionStartupParams;
    showBusyIndicator?: boolean;
    pollForBackgroundJobs?: boolean;
}
export interface AdapterData extends ObjectWithType {
    [name: string]: any;
}
export interface RemoteResponse {
    id?: string;
    '#'?: number;
    adapterData?: Record<string, AdapterData>;
    events?: RemoteEvent[];
    error?: JsonErrorResponse;
    redirectUrl?: string;
    sessionTerminated?: boolean;
    combined?: boolean;
}
export interface SessionStartupResponse extends RemoteResponse {
    startupData?: {
        uiSessionId?: string;
        clientSessionId?: string;
        clientSession?: string;
        reloadPage?: boolean;
        pollingInterval?: number;
        persistent?: boolean;
        inDevelopmentMode?: boolean;
        inspector?: boolean;
        locale?: LocaleModel;
        textMap?: TextMap;
    };
}
export interface SessionStartupParams {
    url?: string;
    geolocationServiceAvailable?: boolean;
    [p: string]: any;
}
export interface FatalMessageOptions {
    header?: string;
    body?: string;
    severity?: StatusSeverity;
    iconId?: string;
    entryPoint?: JQuery;
    hiddenText?: string;
    yesButtonText?: string;
    yesButtonAction?: () => void;
    noButtonText?: string;
    noButtonAction?: () => void;
    cancelButtonText?: string;
    cancelButtonAction?: () => void;
}
export type BlobWithName = Blob & {
    scoutName?: string;
    name?: string;
};
//# sourceMappingURL=Session.d.ts.map