/// <reference types="jquery" />
import { Cell, Column, InitModelOf, LookupCall, LookupCallOrModel, SmartColumnEventMap, SmartColumnModel, SmartField, TableRow } from '../../index';
/**
 * Column where each cell fetches its value using a lookup call.
 *
 * A 'prepareLookupCall' event gets triggered before executing the lookup call and contains two properties, 'lookupCall' and 'row'. Here, 'lookupCall' is the
 * lookup call which is used to fetch one ore more values for a cell. 'row' is the row containing the cell and usually corresponds to the selected row.
 * It should be used instead of the property selectedRows from Table.js which must not be used here.
 * 'row' can be null or undefined in some cases. Hence some care is needed when listening to this event.
 */
export declare class SmartColumn<TValue> extends Column<TValue> {
    model: SmartColumnModel<TValue>;
    eventMap: SmartColumnEventMap<TValue>;
    self: SmartColumn<any>;
    codeType: string;
    lookupCall: LookupCall<TValue>;
    browseHierarchy: boolean;
    browseMaxRowCount: number;
    browseAutoExpandAll: boolean;
    browseLoadIncremental: boolean;
    activeFilterEnabled: boolean;
    protected _lookupCallBatchContext: SmartColumnBatchContext<TValue>;
    constructor();
    protected _init(model: InitModelOf<this>): void;
    protected _initCell(cell: Cell<TValue>): Cell<TValue>;
    protected _calculateCellSortCode(cell: Cell<TValue>): number;
    protected _updateAllCellSortCodes(): void;
    setLookupCall(lookupCall: LookupCallOrModel<TValue>): void;
    protected _setLookupCall(lookupCall: LookupCallOrModel<TValue>): void;
    setCodeType(codeType: string): void;
    protected _setCodeType(codeType: string): void;
    setBrowseHierarchy(browseHierarchy: boolean): void;
    setBrowseMaxRowCount(browseMaxRowCount: number): void;
    setBrowseAutoExpandAll(browseAutoExpandAll: boolean): void;
    setBrowseLoadIncremental(browseLoadIncremental: boolean): void;
    setActiveFilterEnabled(activeFilterEnabled: boolean): void;
    protected _formatValue(value: TValue, row?: TableRow): string | JQuery.Promise<string>;
    /**
     * Defers all invocations of the lookup call for the duration of the current event handler.
     * Once the current event handler completes, all lookup calls are resolved in a single batch.
     */
    protected _batchFormatValue(key: TValue): JQuery.Promise<string>;
    /**
     * Create and set the lookup-row instead of call setValue() as this would execute a lookup by key
     * which is not necessary, since the cell already contains text and value. This also avoids a problem
     * with multiple lookups running at once, see ticket 236960.
     */
    protected _updateEditorFromValidCell(field: SmartField<TValue>, cell: Cell<TValue>): void;
    protected _createEditor(row: TableRow): SmartField<TValue>;
    protected _updateCellFromValidEditor(row: TableRow, field: SmartField<TValue>): void;
    /**
     * Since we don't know the type of the key from the lookup-row we must deal with numeric and string types here.
     */
    protected _hasCellValue(cell: Cell<TValue>): boolean;
    protected _setCellValue(row: TableRow, value: TValue, cell: Cell<TValue>): void;
}
export type SmartColumnBatchContext<TValue> = {
    keySet: Set<TValue>;
    result: JQuery.Promise<Record<string, string>>;
};
//# sourceMappingURL=SmartColumn.d.ts.map