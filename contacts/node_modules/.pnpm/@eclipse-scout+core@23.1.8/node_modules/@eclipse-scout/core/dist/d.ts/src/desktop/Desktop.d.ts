/// <reference types="jquery" />
import { AbstractLayout, Action, BenchColumnLayoutData, DeferredGlassPaneTarget, DesktopBench, DesktopBenchViewActivateEvent, DesktopEventMap, DesktopFormController, DesktopHeader, DesktopModel, DesktopNavigation, DesktopNotification, DisplayParent, EnumObject, Event, EventEmitter, EventHandler, FileChooser, FileChooserController, Form, GlassPaneTarget, InitModelOf, KeyStrokeContext, Menu, MessageBox, MessageBoxController, NativeNotificationVisibility, ObjectOrChildModel, ObjectOrModel, OfflineDesktopNotification, OpenUriHandler, Outline, OutlineContent, Popup, ResponsiveHandler, SimpleTabBox, Splitter, SplitterMoveEndEvent, SplitterMoveEvent, SplitterPositionChangeEvent, TreeDisplayStyle, URL, ViewButton, Widget } from '../index';
export declare class Desktop extends Widget implements DesktopModel, DisplayParent {
    model: DesktopModel;
    eventMap: DesktopEventMap;
    self: Desktop;
    displayStyle: DesktopDisplayStyle;
    title: string;
    selectViewTabsKeyStrokesEnabled: boolean;
    selectViewTabsKeyStrokeModifier: string;
    cacheSplitterPosition: boolean;
    browserHistoryEntry: BrowserHistoryEntry;
    logoId: string;
    logoUrl: string;
    navigationVisible: boolean;
    navigationHandleVisible: boolean;
    logoActionEnabled: boolean;
    benchVisible: boolean;
    headerVisible: boolean;
    geolocationServiceAvailable: boolean;
    benchLayoutData: BenchColumnLayoutData;
    nativeNotificationDefaults: NativeNotificationDefaults;
    menus: Menu[];
    addOns: Widget[];
    dialogs: Form[];
    views: Form[];
    keyStrokes: Action[];
    viewButtons: ViewButton[];
    messageBoxes: MessageBox[];
    fileChoosers: FileChooser[];
    outline: Outline;
    activeForm: Form;
    selectedViewTabs: Form[];
    notifications: DesktopNotification[];
    navigation: DesktopNavigation;
    header: DesktopHeader;
    bench: DesktopBench;
    splitter: Splitter;
    splitterVisible: boolean;
    formController: DesktopFormController;
    messageBoxController: MessageBoxController;
    fileChooserController: FileChooserController;
    initialFormRendering: boolean;
    resizing: boolean;
    offline: boolean;
    inBackground: boolean;
    openUriHandler: OpenUriHandler;
    theme: string;
    dense: boolean;
    animateLayoutChange: boolean;
    url: URL;
    responsiveHandler: ResponsiveHandler;
    $notifications: JQuery;
    $overlaySeparator: JQuery;
    /** @internal */
    _resizeHandler: (event: JQuery.ResizeEvent) => void;
    protected _glassPaneTargetFilters: GlassPaneTargetFilter[];
    protected _offlineNotification: OfflineDesktopNotification;
    /** event listeners */
    protected _benchActiveViewChangedHandler: EventHandler<DesktopBenchViewActivateEvent>;
    protected _popstateHandler: (event: JQuery.TriggeredEvent) => void;
    constructor();
    static DisplayStyle: {
        /**
         * Default style with header, navigation (outline) and bench (forms).
         */
        readonly DEFAULT: "default";
        /**
         * In this style, only the bench is visible, header and navigation are invisible.
         *
         * Currently, you'll also have to manually set {@link navigationVisible} and {@link headerVisible} to false.
         */
        readonly BENCH: "bench";
        /**
         * Compact style that can be used for mobile devices where navigation and bench are never visible simultaneously.
         */
        readonly COMPACT: "compact";
    };
    /**
     * The action that should be performed when handling an "open URI" event.
     */
    static UriAction: {
        /**
         * The object represented by the URI should be downloaded rather then be handled by the browser's rendering engine.
         * It should make the "Save as..." dialog appear which allows the user to store the resource to his local file system.<br>
         * The application's location does not change, and no browser windows or tabs are opened.<br>
         * <br>
         *<b>Important:</b> This action only works if the HTTP header <i>Content-Disposition: attachment</i> is present on the response of the object to be downloaded.<br>
         */
        readonly DOWNLOAD: "download";
        /**
         * The object represented by the URI should be opened by the browser rather than just be downloaded.
         * This will only work if the browser knows how to handle the given URI.
         * E.g. if it points to a pdf file, most browsers will be able to display it using their pdf viewer. Other files may just be downloaded.
         * If the URI points to a website, it will be opened in a separate window or tab.
         * <br>
         * This is also the preferred action to open URIs with <b>special protocols</b> that are registered in the user's system and delegated to some "protocol
         * handler". This handler may then perform actions in a third party application (e.g. <i>mailto:xyz@example.com</i>
         * would open the system's mail application).<br>
         * Note that this action may open the object in a new window or tab tab which may be prevented by
         * the browser's popup blocker mechanism.
         */
        readonly OPEN: "open";
        /**
         * The content represented by the URI should be rendered by the browser and displayed in a new window or tab.<br>
         * The application's location does not change. Note that this action may be prevented by the browser's popup blocker mechanism.
         */
        readonly NEW_WINDOW: "newWindow";
        /**
         * The content represented by the URI should be rendered by the browser and displayed in a new non-modal popup
         * window.
         * Unlike {@link UriAction.NEW_WINDOW} the newly opened window is limited, i.e. it does not contain the location, the toolbar and the menubar.
         * This may not work on every browser (e.g. on a mobile browser the action {@link UriAction.POPUP_WINDOW} will likely behave the same way as {@link UriAction.NEW_WINDOW}).<br>
         * The application's location does not change. Note that this action may be prevented by the browser's popup blocker
         * mechanism.
         */
        readonly POPUP_WINDOW: "popupWindow";
        /**
         * The content represented by the URI should be opened in the same window.
         * This will mainly just replace the location of the current window.
         * If the URI points to another website, the current application will be unloaded and replaced.
         * If it points to a file or uses a special protocol, the handling depends on the used browser.
         */
        readonly SAME_WINDOW: "sameWindow";
    };
    static DEFAULT_THEME: string;
    protected _init(model: InitModelOf<this>): void;
    protected _createKeyStrokeContext(): KeyStrokeContext;
    protected _initKeyStrokeContext(): void;
    protected _createNativeNotificationDefaults(model: DesktopModel): NativeNotificationDefaults;
    /** @see DesktopModel.nativeNotificationDefaults */
    setNativeNotificationDefaults(defaults: NativeNotificationDefaults): void;
    protected _onBenchActivateViewChanged(event: DesktopBenchViewActivateEvent): void;
    protected _render(): void;
    protected _remove(): void;
    protected _postRender(): void;
    protected _setDisplayStyle(displayStyle: DesktopDisplayStyle): void;
    /** @see DesktopModel.dense */
    setDense(dense: boolean): void;
    protected _setDense(dense: boolean): void;
    protected _renderDense(): void;
    protected _createLayout(): AbstractLayout;
    /**
     * Displays attached forms, message boxes and file choosers.
     * Outline does not need to be rendered to show the child elements, it needs to be active (necessary if navigation is invisible)
     */
    protected _renderDisplayChildrenOfOutline(): void;
    protected _removeDisplayChildrenOfOutline(): void;
    computeParentForDisplayParent(displayParent: DisplayParent): Widget;
    protected _renderTitle(): void;
    protected _renderActiveForm(): void;
    protected _renderBench(): void;
    protected _createBench(): DesktopBench;
    protected _removeBench(): void;
    protected _renderBenchVisible(): void;
    protected _renderNavigation(): void;
    protected _createNavigation(): DesktopNavigation;
    protected _removeNavigation(): void;
    protected _renderNavigationVisible(): void;
    protected _renderHeader(): void;
    protected _createHeader(): DesktopHeader;
    protected _removeHeader(): void;
    protected _renderHeaderVisible(): void;
    protected _renderLogoUrl(): void;
    protected _renderSplitterVisible(): void;
    protected _renderSplitter(): void;
    protected _removeSplitter(): void;
    protected _renderInBackground(): void;
    protected _renderBrowserHistoryEntry(): void;
    /**
     * Takes the history.path provided by the browserHistoryEvent and appends additional URL parameters.
     */
    protected _createHistoryPath(history: BrowserHistoryEntry): string;
    protected _setupDragAndDrop(): void;
    updateSplitterVisibility(): void;
    setSplitterVisible(visible: boolean): void;
    updateSplitterPosition(): void;
    protected _disableContextMenu(): void;
    /** @see DesktopModel.outline */
    setOutline(outline: Outline): void;
    protected _setViews(views: Form[]): void;
    protected _setViewButtons(viewButtons: ViewButton[]): void;
    /** @see DesktopModel.menus */
    setMenus(menus: ObjectOrChildModel<Menu>[]): void;
    protected _setMenus(menus: Menu[]): void;
    protected _setKeyStrokes(keyStrokes: Action[]): void;
    /** @see DesktopModel.navigationHandleVisible */
    setNavigationHandleVisible(visible: boolean): void;
    protected _renderNavigationHandleVisible(): void;
    /** @see DesktopModel.navigationVisible */
    setNavigationVisible(visible: boolean): void;
    /** @see DesktopModel.benchVisible */
    setBenchVisible(visible: boolean): void;
    /** @see DesktopModel.headerVisible */
    setHeaderVisible(visible: boolean): void;
    protected _setBenchLayoutData(layoutData: ObjectOrModel<BenchColumnLayoutData>): void;
    protected _setInBackground(inBackground: boolean): void;
    outlineDisplayStyle(): TreeDisplayStyle;
    shrinkNavigation(): void;
    enlargeNavigation(): void;
    /**
     * @param headerVisible whether the desktop header should be visible. Default is true.
     */
    switchToBench(headerVisible?: boolean): void;
    switchToNavigation(): void;
    revalidateHeaderLayout(): void;
    goOffline(): void;
    goOnline(): void;
    protected _removeOfflineNotification(): void;
    addNotification(notification: DesktopNotification): void;
    protected _renderNotification(notification: DesktopNotification): void;
    protected _renderNotifications(): void;
    /**
     * Removes the given notification.
     * @param notification Either an instance of DesktopNavigation or a String containing an ID of a notification instance.
     */
    removeNotification(desktopNotification: DesktopNotification | string): void;
    getPopups(): Popup[];
    getPopupsFor(widget: Widget): Popup[];
    /**
     * Removes every popup which is a descendant of the given widget.
     */
    removePopupsFor(widget: Widget): void;
    /**
     * Opens the uri using {@link OpenUriHandler}
     * @param uri the uri to open
     * @param action the action to be performed on the given uri. Default is Desktop.UriAction.OPEN.
     */
    openUri(uri: string, action?: DesktopUriAction): void;
    bringOutlineToFront(): void;
    sendOutlineToBack(): void;
    /**
     * === Method required for objects that act as 'displayParent' ===
     *
     * Returns 'true' if the Desktop is currently accessible to the user.
     */
    inFront(): boolean;
    /**
     * === Method required for objects that act as 'displayParent' ===
     *
     * @returns the DOM elements to paint a glassPanes over, once a modal Form, message-box, file-chooser or wait-dialog is showed with the Desktop as its 'displayParent'.
     */
    protected _glassPaneTargets(element: Widget): GlassPaneTarget[];
    protected _isGlassPaneTargetFiltered(targetElem: HTMLElement, element: Widget): boolean;
    /**
     * Adds a filter which is applied when the glass pane targets are collected.
     * If the filter returns <code>false</code>, the target won't be accepted and not covered by a glass pane.
     * This filter should be used primarily for elements like the help-popup which stand outside
     * of the regular modality hierarchy.
     *
     * @param filter a function with the parameter target and element. Target is the element which
     *     would be covered by a glass pane, element is the element the user interacts with (e.g. the modal dialog).
     * @see _glassPaneTargets
     */
    addGlassPaneTargetFilter(filter: GlassPaneTargetFilter): void;
    removeGlassPaneTargetFilter(filter: GlassPaneTargetFilter): void;
    /**
     * This 'deferred' object is used because popup windows are not immediately usable when they're opened.
     * That's why we must render the glass-pane of a popup window later. Which means, at the point in time
     * when its $container is created and ready for usage. To avoid race conditions we must also wait until
     * the glass pane renderer is ready. Only when both conditions are fulfilled, we can render the glass
     * pane.
     */
    protected _deferredGlassPaneTarget(popupWindow: EventEmitter & {
        $container: JQuery;
    }): DeferredGlassPaneTarget;
    protected _getBenchGlassPaneTargetsForView(view: Form): JQuery[];
    protected _getTabGlassPaneTargetsForView(view: Form, tabBox: SimpleTabBox<OutlineContent> | DesktopHeader): JQuery[];
    protected _pushPopupWindowGlassPaneTargets(glassPaneTargets: GlassPaneTarget[], element: Widget): void;
    showForm(form: Form, position?: number): void;
    hideForm(form: Form): void;
    /**
     * @see Form.isShown
     */
    isFormShown(form: Form): boolean;
    activateForm(form: Form): void;
    /** @internal */
    _setOutlineActivated(): void;
    /** @internal */
    _setFormActivated(form: Form): void;
    triggerFormActivate(form: Form): void;
    cancelViews(forms: Form[]): void;
    protected _cancelViews(forms: Form[]): void;
    /**
     * Called when the animation triggered by animationLayoutChange is complete (e.g. navigation or bench got visible/invisible)
     */
    onLayoutAnimationComplete(): void;
    onLayoutAnimationStep(): void;
    onResize(event: JQuery.ResizeEvent): void;
    resetPopstateHandler(): void;
    setPopstateHandler(handler: (event: JQuery.TriggeredEvent) => void): void;
    onPopstate(event: JQuery.TriggeredEvent): void;
    protected _onSplitterMove(event: SplitterMoveEvent): void;
    protected _onSplitterPositionChange(event: SplitterPositionChangeEvent): void;
    protected _onSplitterMoveEnd(event: SplitterMoveEndEvent): void;
    protected _loadCachedSplitterPosition(): string;
    protected _storeCachedSplitterPosition(splitterPosition: number): void;
    /** @internal */
    _onNotificationRemove(event: Event<DesktopNotification>): void;
    onReconnecting(): void;
    onReconnectingSucceeded(): void;
    onReconnectingFailed(): void;
    dataChange(dataType: object): void;
    protected _activeTheme(): string;
    logoAction(): void;
    protected _initTheme(): void;
    /**
     * Changes the current theme.
     *
     * The theme name is stored in a persistent cookie called scout.ui.theme.
     * In order to activate it, the browser is reloaded so that the CSS files for the new theme can be downloaded.
     *
     * Since it is a persistent cookie, the theme will be activated again the next time the app is started, unless the cookie is deleted.
     * @see DesktopModel.theme
     */
    setTheme(theme: string): void;
    protected _switchTheme(theme: string): void;
    /**
     * Moves all the given overlays (popups, dialogs, message boxes etc.) before the target overlay and activates the focus context of the target overlay.
     *
     * @param overlaysToMove the overlays which should be moved before the target overlay
     * @param $targetOverlay the overlay which should eventually be on top of the movable overlays
     */
    moveOverlaysBehindAndFocus(overlaysToMove: HTMLElement[], $targetOverlay: JQuery | HTMLElement): void;
    /**
     * If the given widget is an overlay (i.e. its $container is one of the elements after $overlaySeparator),
     * the DOM order is adjusted such that the overlay is not displayed in front of other overlays that
     * belong to a later "context".
     *
     * For example, when two dialogs are open, both are rendered after the desktop's $overlaySeparator.
     *
     * - Context 0: Any overlay opened by a view is rendered before dialog1.$container.
     * - Context 1: Any overlay opened by dialog1 is rendered between dialog1.$container and before dialog2.$container.
     * - Context 2: Any overlay opened by dialog2 is rendered after dialog2.$container.
     *
     * Within each context, tooltips are always displayed first, followed by all other overlays (e.g. popups),
     * each in their opening order.
     */
    adjustOverlayOrder(overlay: Widget): void;
    repositionTooltips(): void;
    protected _renderTrackFocus(): void;
    protected _onFocusIn(event: JQuery.FocusInEvent): void;
}
export type DesktopDisplayStyle = EnumObject<typeof Desktop.DisplayStyle>;
export type DesktopUriAction = EnumObject<typeof Desktop.UriAction>;
export type NativeNotificationDefaults = {
    title?: string;
    iconId?: string;
    visibility?: NativeNotificationVisibility;
};
export type BrowserHistoryEntry = {
    path: string;
    title: string;
    deepLinkPath: string;
    pathVisible: boolean;
};
export type DesktopHistoryState = {
    deepLinkPath: string;
};
export type GlassPaneTargetFilter = (target: HTMLElement, element: Widget) => boolean;
//# sourceMappingURL=Desktop.d.ts.map