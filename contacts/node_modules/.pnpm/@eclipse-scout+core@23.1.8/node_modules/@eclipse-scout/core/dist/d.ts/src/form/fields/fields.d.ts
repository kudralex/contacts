import { FormField, Popup, ValueField, Widget } from '../../index';
/**
 * Calls JQuery $.text() for touch-devices and $.val() for all other devices, used together with #makeInputOrDiv().
 * Works as setter when called with 2 arguments, works a getter when called with 1 arguments.
 *
 * @returns when called with 1 argument: $field.text() or $field.val()
 */
declare function valOrText($field: JQuery, text: string): any;
declare function valOrText($field: JQuery): string;
export declare const fields: {
    /**
     * @param $parent used to determine which HTML document is used to create the new HTML element
     * @returns an INPUT element as used in Scout forms.
     */
    makeTextField($parent: JQuery, cssClass?: string): JQuery<HTMLInputElement>;
    appendIcon($field: JQuery, cssClass?: string): JQuery;
    initTouch(field: {
        embedded: boolean;
        touchMode: boolean;
    }, model: {
        embedded?: boolean;
        touchMode?: boolean;
    }): void;
    valOrText: typeof valOrText;
    /**
     * Creates a DIV element for touch-devices and an INPUT element for all other devices,
     * depending on the touch flag of the given field.
     */
    makeInputOrDiv(field: Widget & {
        touchMode?: boolean;
    }, cssClass?: string): JQuery;
    /**
     * Creates a DIV element that looks like an INPUT element.
     */
    makeInputDiv(field: Widget, cssClass?: string): JQuery;
    /**
     * The INPUT element does not process the click event when the field is disabled.
     * However, the DIV element used in touch-mode does process the event anyway, that's why this check is required.
     */
    handleOnClick(field: Widget & {
        popup?: Popup;
        embedded?: boolean;
    }): boolean;
    /**
     * Calls activate() on the first focusable field of the given fields. Does nothing if the widget is disabled or not rendered.
     */
    activateFirstField(widget: Widget, fieldArr: FormField[]): void;
    /**
     * Links the given element with the given label by setting aria-labelledby.<br>
     * This allows screen readers to build a catalog of the elements on the screen and their relationships, for example, to read the label when the input is focused.
     */
    linkElementWithLabel($elem: JQuery, $label: JQuery): void;
    /**
     * @param field a ValueField which works like a Proposal- or SmartField.
     * @returns Whether or not the target is on the field (including popup and tooltip)
     */
    eventOutsideProposalField(field: ValueField<any> & {
        popup: Popup;
    }, target: JQuery | Element): boolean;
    /**
     * Selects the tab containing the given {@link FormField} for all parent tabBoxes.
     * This ensures that the given field could be seen (if visible itself).
     *
     * @param field The field whose parent tabs should be selected.
     */
    selectAllParentTabsOf(field: FormField): void;
    /**
     * Selects the given tabItem if it is a {@link TabItem}.
     *
     * @param tabItem The tab to be selected.
     */
    selectIfIsTab(tabItem: FormField): void;
    /**
     * Toggles {@link FormField.statusPosition} based on the given predicate in order to enlarge or reset the box header line while scrolling.
     * The header line is enlarged to match the width of the scroll shadow.
     */
    adjustStatusPositionForScrollShadow(box: FormField, predicate: () => boolean): void;
};
export {};
//# sourceMappingURL=fields.d.ts.map