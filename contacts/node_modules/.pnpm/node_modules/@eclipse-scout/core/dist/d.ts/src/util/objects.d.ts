import { Primitive } from '../index';
export declare const objects: {
    /**
     * Uses Object.create(null) to create an object without a prototype. This is different to use the literal {} which links the object to Object.prototype.
     * <p>
     * Not using the literal has the advantage that the object does not contain any inherited properties like `toString` so it is not necessary to use `o.hasOwnProperty(p)`
     * instead of `p in o` to check for the existence.
     *
     * @param [properties] optional initial properties to be set on the new created object
     */
    createMap(properties?: object): any;
    /**
     * Copies all the properties (including the ones from the prototype.) from dest to source
     * @param [filter] an array of property names.
     * @returns the destination object (the destination parameter will be modified as well)
     */
    copyProperties<D>(source: object, dest: D, filter?: string[] | string): D;
    /**
     * Copies the own properties (excluding the ones from the prototype) from source to dest.
     * If a filter is specified, only the properties matching the ones in the filter are copied.
     * @param [filter] an array of property names.
     * @returns the destination object (the destination parameter will be modified as well)
     */
    copyOwnProperties<D_1>(source: object, dest: D_1, filter?: string[] | string): D_1;
    /**
     * Counts and returns the properties of a given object or map (see #createMap).
     */
    countOwnProperties(obj: object): number;
    /**
     * Copies the specified properties (including the ones from the prototype) from source to dest.
     * Properties that already exist on dest are NOT overwritten.
     */
    extractProperties<D_2>(source: object, dest: D_2, properties: string[]): D_2;
    /**
     * returns
     *  - true if the obj has at least one of the given properties.
     *  - false if the obj has none of the given properties.
     */
    someOwnProperties(obj: object, properties: string[] | string): boolean;
    /**
     * returns
     *  - true if the obj or its prototypes have at least one of the given properties.
     *  - false if the obj or its prototypes have none of the given properties.
     */
    someProperties(obj: object, properties: string[] | string): boolean;
    valueCopy<T>(obj: T): T;
    /**
     * Returns the first object with the given property and propertyValue or null if there is no such object within parentObj.
     * @param property property to search for
     * @param propertyValue value of the property
     */
    findChildObjectByKey(parentObj: any, property: string, propertyValue: any): any;
    /**
     * This function returns the value of a property from the provided object specified by the second path parameter.
     * The path consists of a dot separated series of property names (e.g. foo, foo.bar, foo.bar.baz).
     * In addition, traversing into array properties is possible by specifying a suitable filter for the element's id property in square brackets (e.g. foo[bar], foo.bar[baz]).
     *
     * Example:
     *
     * let obj = {
     *   foo: {
     *     bar: {
     *       foobar: 'val1'
     *     }
     *   },
     *   baz: [
     *     {
     *       id: 'baz1',
     *       value: 'val2'
     *     },
     *     {
     *       id: 'baz2',
     *       value: 'val3'
     *     }
     *   ]
     * }
     *
     * objects.getByPath(obj, 'foo') === obj.foo;
     * objects.getByPath(obj, 'foo.bar') === obj.foo.bar;
     * objects.getByPath(obj, 'baz[baz1]') → { id: 'baz1', value: 'val2' }
     * objects.getByPath(obj, 'baz[baz2].value') → 'val3'
     *
     * @param object The object to select a property from.
     * @param path The path for the selection.
     * @returns Object Returns the selected object.
     * @throws Throws an error, if the provided parameters are malformed, or a property could not be found/a id property filter does not find any elements.
     */
    getByPath(object: object, path: string): any;
    /**
     * @returns true if the given object is an object: no primitive type (number, string, boolean, bigint, symbol), no array, not null and not undefined.
     */
    isPlainObject<T_1>(obj: T_1): obj is Exclude<T_1, Primitive | T_1[]>;
    /**
     * Null-safe access the property of objects. Instead of using this function consider using conditional chaining with the elvis operator: obj?.foo?.bar.
     * Examples:
     * <ul>
     * <li><code>optProperty(obj, 'value');</code> try to access and return obj.value</li>
     * <li><code>optProperty(obj, 'foo', 'bar');</code> try to access and return obj.foo.bar</li>
     * </ul>
     *
     * @returns the value of the requested property or undefined if the property does not exist on the object
     */
    optProperty(obj: object, ...properties: string[]): any;
    /**
     * Returns true if:
     * - obj is not undefined or null
     * - obj not isNaN
     * - obj isFinite
     *
     * This method is handy in cases where you want to check if a number is set. Since you cannot write:
     *   if (myNumber) { ...
     *
     * Because when myNumber === 0 would also resolve to false. In that case use instead:
     *   if (isNumber(myNumber)) { ...
     */
    isNumber(obj: any): obj is number;
    isString(obj: any): obj is string;
    isNullOrUndefined(obj: any): obj is null;
    isFunction(obj: any): obj is Function;
    /**
     * Returns true if the given object is {@link isNullOrUndefined null or undefined}, an
     * {@link arrays#empty empty array} or an {@link isEmpty empty object}.
     */
    isNullOrUndefinedOrEmpty(obj: any): boolean;
    isArray(obj: any): obj is any[];
    /**
     * Checks whether the provided value is a promise or not.
     * @param value The value to check.
     * @returns true, in case the provided value is a thenable, false otherwise.
     *
     * Note: This method checks whether the provided value is a "thenable" (see https://promisesaplus.com/#terminology).
     *       Checking for promise would require to check the behavior which is not possible. So you could provide an object
     *       with a "then" function that does not conform to the Promises/A+ spec but this method would still return true.
     */
    isPromise(value: any): value is PromiseLike<any>;
    /**
     * Returns values from the given (map) object. By default, only values of 'own' properties are returned.
     *
     * @param obj
     * @param all can be set to true to return all properties instead of own properties
     * @returns an Array with values
     */
    values<K extends PropertyKey, V>(obj: Record<K, V>, all?: boolean): V[];
    /**
     * @returns the key (name) of a property with given value
     */
    keyByValue<V_1>(obj: Record<string, V_1>, value: V_1): string;
    /**
     * Java-like equals method. Compares the given objects by checking with ===, if that fails, the function
     * checks if both objects have an equals function and use the equals function to compare the two objects
     * by value.
     * @returns true if both objects are equals by reference or by value
     */
    equals(objA: any, objB: any): boolean;
    /**
     * Compare two objects and all its child elements recursively.
     * @returns true if both objects and all child elements are equals by value or implemented equals method
     */
    equalsRecursive(objA: any, objB: any): boolean;
    /**
     * Compares a list of properties of two objects by using the equals method for each property.
     */
    propertiesEquals(objA: object, objB: object, properties: string[]): boolean;
    /**
     * @returns the function identified by funcName from the given object. The function will return an error
     *     if that function does not exist. Use this function if you modify an existing framework function
     *     to find problems after refactoring / renaming as soon as possible.
     */
    mandatoryFunction(obj: object, funcName: string): Function;
    /**
     * Use this method to replace a function on a prototype of an object. It checks if that function exists
     * by calling <code>mandatoryFunction</code>.
     */
    replacePrototypeFunction(obj: any, funcName: string, func: Function, rememberOrig: boolean): void;
    /**
     * @returns a real Array for the pseudo-array 'arguments'.
     */
    argumentsToArray(args: IArguments): any[];
    /**
     * Used to loop over 'arguments' pseudo-array with forEach.
     */
    forEachArgument(args: IArguments, func: (value: any, index: number, args: any[]) => void): void;
    /**
     * Development utility to check if overrides in JavaScript "classes" are correct.
     *
     * How to use:
     *   1. Start application in development mode (non-minimized).
     *   2. Open browser's development console
     *   3. Type: checkFunctionOverrides().join('\n')
     */
    checkFunctionOverrides(): string[];
    /**
     * @param value text which contains a constant reference like '${const:FormField.LabelPosition.RIGHT}'.
     * @returns the resolved constant value or the unchanged input value if the constant could not be resolved.
     */
    resolveConst(value: string, constType?: any): any;
    resolveConstProperty(object: object, config: {
        property: string;
        constType: any;
    }): void;
    /**
     * Cleans the given object, i.e. removes all top-level properties with values that are null, undefined or
     * consist of an empty array or an empty object. This is useful to have a minimal data object.
     *
     * This method is *not* recursive.
     *
     * The object is modified *in-place* and is also returned.
     *
     * If the given object is set but not a {@link isPlainObject plain object}, an error is thrown.
     *
     * @see isNullOrUndefinedOrEmpty
     */
    removeEmptyProperties(object: any): any;
    /**
     * @returns
     *  - true if the obj is empty, null or undefined
     *  - false if the obj is not empty
     *  - undefined if the obj is not an object
     */
    isEmpty(obj: any): boolean | undefined;
    /**
     * Converts any non-string argument to a string that can be used as an object property name.
     * Complex objects are converted to their JSON representation (instead of returning something
     * non-descriptive such as '[Object object]').
     */
    ensureValidKey(key: any): string;
};
//# sourceMappingURL=objects.d.ts.map