import { DateFormat, DateRange, Locale } from '../index';
export interface JsonDateRange {
    from: string;
    to: string;
}
export declare const dates: {
    shift(date: Date, years: number, months?: number, days?: number): Date;
    shiftTime(date: Date, hours?: number, minutes?: number, seconds?: number, milliseconds?: number): Date;
    shiftToNextDayOfType(date: Date, day: number): Date;
    /**
     * Finds the next date (based on the given date) that matches the given day in week and date.
     *
     * @param date Start date
     * @param dayInWeek 0-6
     * @param dayInMonth 1-31
     */
    shiftToNextDayAndDate(date: Date, dayInWeek: number, dayInMonth: number): Date;
    shiftToPreviousDayOfType(date: Date, day: number): Date;
    shiftToNextOrPrevDayOfType(date: Date, day: number, direction: number): Date;
    shiftToNextOrPrevMonday(date: Date, direction: number): Date;
    /**
     * Ensures that the given date is really a date.
     * <p>
     * If it already is a date, the date will be returned.
     * Otherwise parseJsonDate is used to create a Date.
     *
     * @param date may be of type date or string.
     */
    ensure(date: Date | string): Date;
    ensureMonday(date: Date, direction: number): Date;
    isSameTime(date: Date, date2: Date): boolean;
    isSameDay(date: Date, date2: Date): boolean;
    isSameMonth(date: Date, date2: Date): boolean;
    /**
     * Returns the difference of the two dates in number of months.
     */
    compareMonths(date1: Date, date2: Date): number;
    /**
     * Returns the difference of the two dates in number of days.
     */
    compareDays(date1: Date, date2: Date): number;
    orderWeekdays(weekdays: string[], firstDayOfWeekArg: number): string[];
    /**
     * Returns the week number according to ISO 8601 definition:
     * - All years have 52 or 53 weeks.
     * - The first week is the week with January 4th in it.
     * - The first day of a week is Monday, the last day is Sunday
     *
     * This is the default behavior. By setting the optional second argument 'option',
     * the first day in a week can be changed (e.g. 0 = Sunday). The returned numbers weeks are
     * not ISO 8601 compliant anymore, but can be more appropriate for display in a calendar. The
     * argument can be a number, a 'scout.Locale' or a 'scout.DateFormat' object.
     */
    weekInYear(date: Date, option?: number | Locale | DateFormat): number;
    /** @internal */
    _thursdayOfWeek(date: Date, firstDayOfWeekArg: number): Date;
    firstDayOfWeek(date: Date, firstDayOfWeekArg: number): Date;
    /**
     * Parses a string that corresponds to one of the canonical JSON transfer formats
     * and returns it as a JavaScript 'Date' object.
     *
     * @see JsonDate.java
     */
    parseJsonDate(jsonDate: string): Date;
    /**
     * Converts the given date object to a JSON string. By default, the local time zone
     * is used to built the result, time zone information itself is not part of the
     * result. If the argument 'utc' is set to true, the result is built using the
     * UTC values of the date. Such a result string is marked with a trailing 'Z' character.
     *
     * @see JsonDate.java
     */
    toJsonDate(date: Date, utc?: boolean, includeDate?: boolean, includeTime?: boolean): string;
    toJsonDateRange(range: DateRange): JsonDateRange;
    /**
     * Creates a new JavaScript Date object by parsing the given string. This method is not intended to be
     * used in application code, but provides a quick way to create dates in unit tests.
     *
     * The format is as follows:
     *
     * [Year#4|5]-[Month#2]-[Day#2] [Hours#2]:[Minutes#2]:[Seconds#2].[Milliseconds#3][Z]
     *
     * The year component is mandatory, but all others are optional (starting from the beginning).
     * The date is constructed using the local time zone. If the last character is 'Z', then
     * the values are interpreted as UTC date.
     */
    create(dateString: string): Date;
    /**
     * Returns a new Date. Use this function in place of <code>new Date();</code> in your productive code
     * when you want to provide a fixed date instead of the system time/date for unit tests. In your unit test
     * you can replace this function with a function that provides a fixed date. Don't forget to restore the
     * original function when you cleanup/tear-down the test.
     */
    newDate(): Date;
    format(date: Date, locale: Locale, pattern?: string): string;
    /**
     * Uses the default date and time format patterns from the locale to format the given date.
     */
    formatDateTime(date: Date, locale: Locale): string;
    compare(a: Date, b: Date): number;
    equals(a: Date, b: Date): boolean;
    /**
     * This combines a date and time, passed as date objects to one object with the date part of param date and the time part of param time.
     * <p>
     * If time is omitted, 00:00:00 is used as time part.<br>
     * If date is omitted, 1970-01-01 is used as date part independent of the time zone, means it is 1970-01-01 in every time zone.
     */
    combineDateTime(date: Date, time?: Date): Date;
    /**
     * Returns <code>true</code> if the given year is a leap year, i.e if february 29 exists in that year.
     */
    isLeapYear(year: number): boolean;
    /**
     * Returns the given date with time set to midnight (hours, minutes, seconds, milliseconds = 0).
     *
     * @param date (required)
     *          The date to truncate.
     * @param [createCopy] (optional)
     *          If this flag is true, a copy of the given date is returned (the input date is not
     *          altered). If the flag is false, the given object is changed and then returned.
     *          The default value for this flag is "true".
     */
    trunc(date: Date, createCopy?: boolean): Date;
    /**
     * Returns the given date with time set to midnight (hours, minutes, seconds, milliseconds = 0).
     *
     * @param date
     *          The date to truncate.
     * @param [minutesResolution] default is 30
     *          The amount of minutes added to every full hour XX:00 until > XX+1:00. The given date will rounded up to the next valid time.
     *          e.g. time:15:05, resolution 40  -> 15:40
     *               time: 15:41 resolution 40 -> 16:00
     * @param [createCopy]
     *          If this flag is true, a copy of the given date is returned (the input date is not
     *          altered). If the flag is false, the given object is changed and then returned.
     *          The default value for this flag is "true".
     */
    ceil(date: Date, minutesResolution?: number, createCopy?: boolean): Date;
};
//# sourceMappingURL=dates.d.ts.map