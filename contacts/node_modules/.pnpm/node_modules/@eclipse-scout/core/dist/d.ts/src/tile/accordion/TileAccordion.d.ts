import { Accordion, Comparator, Event, EventDelegator, EventHandler, Filter, FilterOrFunction, FilterResult, FilterSupport, Group, InitModelOf, KeyStrokeContext, ObjectOrChildModel, PropertyChangeEvent, TextFilter, Tile, TileAccordionEventMap, TileAccordionLayout, TileAccordionModel, TileAccordionSelectionHandler, TileGrid, TileGridLayoutConfig } from '../../index';
export declare class TileAccordion extends Accordion implements TileAccordionModel {
    model: TileAccordionModel;
    eventMap: TileAccordionEventMap;
    self: TileAccordion;
    groups: Group<TileGrid>[];
    gridColumnCount: number;
    multiSelect: boolean;
    selectable: boolean;
    takeTileFiltersFromGroup: boolean;
    tileComparator: Comparator<Tile>;
    filters: Filter<Tile>[];
    tileGridLayoutConfig: TileGridLayoutConfig;
    tileGridSelectionHandler: TileAccordionSelectionHandler;
    withPlaceholders: boolean;
    virtual: boolean;
    textFilterEnabled: boolean;
    filterSupport: FilterSupport<Tile>;
    createTextFilter: () => TextFilter<Tile>;
    updateTextFilterText: string;
    $filterFieldContainer: JQuery;
    protected _selectionUpdateLocked: boolean;
    protected _tileGridPropertyChangeHandler: EventHandler<PropertyChangeEvent>;
    protected _groupBodyHeightChangeHandler: EventHandler<Event<Group<TileGrid>>>;
    constructor();
    protected _render(): void;
    protected _createLayout(): TileAccordionLayout;
    protected _renderProperties(): void;
    protected _remove(): void;
    protected _init(model: InitModelOf<this>): void;
    protected _createKeyStrokeContext(): KeyStrokeContext;
    protected _initGroup(group: Group<TileGrid> & {
        body: TileGrid & {
            __tileAccordionEventDelegator?: EventDelegator;
        };
    }): void;
    protected _deleteGroup(group: Group<TileGrid> & {
        body: TileGrid & {
            __tileAccordionEventDelegator?: EventDelegator;
        };
    }): void;
    setGroups(groups: Group<TileGrid>[]): void;
    /** @see TileAccordionModel.gridColumnCount */
    setGridColumnCount(gridColumnCount: number): void;
    /** @see TileAccordionModel.tileGridLayoutConfig */
    setTileGridLayoutConfig(layoutConfig: TileGridLayoutConfig): void;
    /** @see TileAccordionModel.withPlaceholders */
    setWithPlaceholders(withPlaceholders: boolean): void;
    /** @see TileAccordionModel.virtual */
    setVirtual(virtual: boolean): void;
    /** @see TileAccordionModel.selectable */
    setSelectable(selectable: boolean): void;
    /** @see TileAccordionModel.multiSelect */
    setMultiSelect(multiSelect: boolean): void;
    getGroupById(id: string): Group<TileGrid>;
    getGroupByTile(tile: Tile): Group<TileGrid>;
    /**
     * Distribute the tiles to the corresponding groups and returns an object with group id as key and array of tiles as value.
     * Always returns all current groups even if the given tiles may not be distributed to all groups.
     */
    protected _groupTiles(tiles: Tile[]): Record<string, Tile[]>;
    deleteTile(tile: Tile): void;
    deleteTiles(tilesToDelete: Tile[] | Tile): void;
    deleteAllTiles(): void;
    /**
     * Distributes the given tiles to their corresponding groups.
     *
     * If the list contains new tiles not assigned to a group yet, an exception will be thrown.
     */
    setTiles(tilesOrModels: ObjectOrChildModel<Tile> | ObjectOrChildModel<Tile>[]): void;
    getTiles(): Tile[];
    getTileCount(): number;
    /**
     * @param filter The filters to add.
     * @param applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.
     */
    addFilter(filter: FilterOrFunction<Tile> | FilterOrFunction<Tile>[], applyFilter?: boolean): void;
    /**
     * @param filter The filters to remove.
     * @param applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.
     */
    removeFilter(filter: FilterOrFunction<Tile> | FilterOrFunction<Tile>[], applyFilter?: boolean): void;
    /**
     * @param filter The new filters.
     * @param applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.
     */
    setFilters(filters: FilterOrFunction<Tile> | FilterOrFunction<Tile>[], applyFilter?: boolean): void;
    protected _setFilters(filter: FilterOrFunction<Tile> | FilterOrFunction<Tile>[]): void;
    filter(): void;
    protected _filter(): FilterResult<Tile>;
    protected _createFilterSupport(): FilterSupport<Tile>;
    protected _createTextFilter(): TextFilter<Tile>;
    protected _updateTextFilterText(filter: Filter<Tile>, text: string): boolean;
    /** @see TileAccordionModel.textFilterEnabled */
    setTextFilterEnabled(textFilterEnabled: boolean): void;
    isTextFilterFieldVisible(): boolean;
    protected _renderTextFilterEnabled(): void;
    getFilteredTiles(): Tile[];
    getFilteredTileCount(): number;
    /**
     * Compared to {@link getFilteredTiles()}, this function considers the collapsed state of the group as well, meaning only filtered tiles of expanded groups are returned.
     */
    getVisibleTiles(): Tile[];
    /**
     * Compared to {@link getFilteredTiles()}, this function considers the collapsed state of the group as well, meaning only filtered tiles of expanded groups are counted.
     */
    getVisibleTileCount(): number;
    findVisibleTileIndexAt(x: number, y: number, startIndex?: number, reverse?: boolean): number;
    /**
     * Selects the given tiles and deselects the previously selected ones.
     *
     * Tiles, that are currently invisible due to an active filter, are excluded and won't be selected.
     */
    selectTiles(tiles: Tile[]): void;
    /** @see selectTiles */
    selectTile(tile: Tile): void;
    /**
     * Selects all tiles. As for every selection operation: only considers filtered tiles and tiles of expanded groups
     */
    selectAllTiles(): void;
    deselectTiles(tiles: Tile[]): void;
    deselectTile(tile: Tile): void;
    deselectAllTiles(): void;
    addTilesToSelection(tiles: Tile[]): void;
    addTileToSelection(tile: Tile): void;
    getSelectedTiles(): Tile[];
    getSelectedTile(): Tile;
    getSelectedTileCount(): number;
    /**
     * Deselects every tile if all tiles are selected. Otherwise, selects all tiles.
     */
    toggleSelection(): void;
    /** @see TileAccordionModel.tileComparator */
    setTileComparator(comparator: Comparator<Tile>): void;
    sortTiles(): void;
    setFocusedTile(tile: Tile): void;
    getFocusedTile(): Tile;
    getVisibleGridRowCount(): number;
    getVisibleGridX(tile: Tile): number;
    getVisibleGridY(tile: Tile): number;
    getGroupByVisibleRow(rowToFind: number): Group<TileGrid>;
    /**
     * @returns the index of the row where the group is located.<p>
     *          Example: There are 3 rows and 2 groups. The first group contains 2 rows, the second 1 row.
     *          The index of the first group is 0, the index of the second group is 2.
     */
    getVisibleRowByGroup(groupToFind: Group<TileGrid>): number;
    expandedGroups(): Group<TileGrid>[];
    protected _handleSelectionChanged(tileGrid: TileGrid): void;
    protected _onTileGridPropertyChange(event: PropertyChangeEvent<any, TileGrid>): void;
    protected _onGroupCollapsedChange(event: PropertyChangeEvent<boolean, Group<TileGrid>>): void;
    protected _handleCollapsed(group: Group<TileGrid>): void;
    protected _onGroupBodyHeightChange(event: Event<Group<TileGrid>>): void;
    protected _onGroupBodyHeightChangeDone(event: Event<Group<TileGrid>>): void;
    /**
     * @returns the first fully visible tile at the scrollTop.
     */
    tileAtScrollTop(scrollTop: number): Tile;
}
//# sourceMappingURL=TileAccordion.d.ts.map