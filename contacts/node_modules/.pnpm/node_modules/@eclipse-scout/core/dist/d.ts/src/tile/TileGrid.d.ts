/// <reference types="jquery" />
import { AbstractGrid, Comparator, ContextMenuPopup, DoubleClickSupport, EnumObject, Filter, FilterOrFunction, FilterResult, FilterSupport, InitModelOf, KeyStrokeContext, LoadingSupport, LogicalGrid, Menu, MenuDestinations, MenuFilter, ObjectOrChildModel, ObjectOrModel, PlaceholderTile, Predicate, Range, ScrollToOptions, TextFilter, Tile, TileGridEventMap, TileGridLayout, TileGridLayoutConfig, TileGridModel, TileGridSelectionHandler, UpdateFilteredElementsOptions, VirtualScrolling, Widget } from '../index';
export declare class TileGrid extends Widget implements TileGridModel {
    model: TileGridModel;
    eventMap: TileGridEventMap;
    self: TileGrid;
    logicalGrid: AbstractGrid;
    animateTileRemoval: boolean;
    animateTileInsertion: boolean;
    comparator: Comparator<Tile>;
    contextMenu: ContextMenuPopup;
    empty: boolean;
    filters: Filter<Tile>[];
    filteredTiles: Tile[];
    filteredElementsDirty: boolean;
    focusedTile: Tile;
    gridColumnCount: number;
    prefGridColumnCount: number;
    layoutConfig: TileGridLayoutConfig;
    menus: Menu[];
    multiSelect: boolean;
    renderAnimationEnabled: boolean;
    selectable: boolean;
    selectedTiles: Tile[];
    selectionHandler: TileGridSelectionHandler;
    scrollable: boolean;
    startupAnimationDone: boolean;
    startupAnimationEnabled: boolean;
    tiles: Tile[];
    tileRemovalPendingCount: number;
    viewRangeSize: number;
    viewRangeRendered: Range;
    virtual: boolean;
    virtualScrolling: VirtualScrolling;
    withPlaceholders: boolean;
    placeholderProducer: () => ObjectOrModel<PlaceholderTile>;
    textFilterEnabled: boolean;
    filterSupport: FilterSupport<Tile>;
    createTextFilter: () => TextFilter<Tile>;
    updateTextFilterText: string;
    $filterFieldContainer: JQuery;
    $fillBefore: JQuery;
    $fillAfter: JQuery;
    protected _doubleClickSupport: DoubleClickSupport;
    protected _filterMenusHandler: (menuItems: Menu[], destination: MenuDestinations) => Menu[];
    protected _renderViewPortAfterAttach: boolean;
    protected _scrollParentScrollHandler: (event: JQuery.ScrollEvent) => void;
    constructor();
    static MenuTypes: {
        readonly EmptySpace: "TileGrid.EmptySpace";
        readonly SingleSelection: "TileGrid.SingleSelection";
        readonly MultiSelection: "TileGrid.MultiSelection";
    };
    protected _init(model: InitModelOf<this>): void;
    protected _createKeyStrokeContext(): KeyStrokeContext;
    protected _initVirtualScrolling(): void;
    protected _createVirtualScrolling(): VirtualScrolling;
    protected _createLoadingSupport(): LoadingSupport;
    protected _initKeyStrokeContext(): void;
    protected _initTiles(): void;
    protected _initTile(tile: Tile): void;
    protected _render(): void;
    protected _createLayout(): TileGridLayout;
    protected _renderProperties(): void;
    protected _remove(): void;
    protected _renderOnAttach(): void;
    protected _renderEnabled(): void;
    protected _updateTabbable(): void;
    insertTile(tile: ObjectOrChildModel<Tile>): void;
    insertTiles(tilesToInsert: ObjectOrChildModel<Tile> | ObjectOrChildModel<Tile>[], appendPlaceholders?: boolean): void;
    deleteTile(tile: Tile): void;
    deleteTiles(tilesToDelete: Tile | Tile[], appendPlaceholders?: boolean): void;
    deleteAllTiles(): void;
    setTiles(tilesOrModels: ObjectOrChildModel<Tile> | ObjectOrChildModel<Tile>[], appendPlaceholders?: boolean): void;
    protected _insertTiles(tiles: Tile[]): void;
    protected _insertTile(tile: Tile): void;
    protected _renderTile(tile: Tile): void;
    protected _renderInsertTiles(tiles: Tile[]): void;
    protected _removeAllTiles(): void;
    protected _renderAllTiles(): void;
    protected _deleteTiles(tiles: Tile[]): void;
    protected _deleteTile(tile: Tile): void;
    protected _animateTileRemoval(tile: Tile): boolean;
    protected _animateTileInsertion(tile: Tile): boolean;
    protected _onAnimatedTileRemove(tile: Tile): void;
    /**
     * Sets a comparator that is used to sort the tiles. After setting a comparator, you need to call {@link sort}.
     *
     * The tiles will be sorted automatically whenever new tiles are inserted.
     */
    setComparator(comparator: Comparator<Tile>): void;
    protected _sortWhileInit(): void;
    sort(): void;
    protected _sort(tiles: Tile[]): void;
    invalidateLayoutTree(invalidateParents?: boolean): void;
    /** @see TileGridModel.gridColumnCount */
    setGridColumnCount(gridColumnCount: number): void;
    protected _setGridColumnCount(gridColumnCount: number): void;
    /** @see TileGridModel.layoutConfig */
    setLayoutConfig(layoutConfig: ObjectOrModel<TileGridLayoutConfig>): void;
    protected _setLayoutConfig(layoutConfig: ObjectOrModel<TileGridLayoutConfig>): void;
    protected _renderLayoutConfig(): void;
    protected _setMenus(menus: Menu[]): void;
    protected _filterMenus(menus: Menu[], destination: MenuDestinations, onlyVisible?: boolean, enableDisableKeyStrokes?: boolean, notAllowedTypes?: string | string[]): Menu[];
    showContextMenu(options: {
        pageX?: number;
        pageY?: number;
    }): void;
    /**
     * @param options may contain pageX, pageY, menuItems and menuFilter.
     * If these properties are not provided they are determined automatically.
     * @internal
     */
    _showContextMenu(options?: {
        pageX?: number;
        pageY?: number;
        menuItems?: Menu[];
        menuFilter?: MenuFilter;
    }): void;
    /** @see TileGridModel.scrollable */
    setScrollable(scrollable: boolean): void;
    protected _renderScrollable(): void;
    protected _onScroll(event: JQuery.ScrollEvent): void;
    protected _onScrollParentScroll(event: JQuery.ScrollEvent): void;
    setWithPlaceholders(withPlaceholders: boolean): void;
    protected _renderWithPlaceholders(): void;
    setPlaceholderProducer(placeholderProducer: () => ObjectOrModel<PlaceholderTile>): void;
    fillUpWithPlaceholders(): void;
    tilesWithoutPlaceholders(): Tile[];
    protected _createPlaceholders(): PlaceholderTile[];
    protected _createPlaceholder(): PlaceholderTile;
    protected _deleteObsoletePlaceholders(): void;
    protected _deleteAllPlaceholders(): void;
    placeholders(): PlaceholderTile[];
    protected _insertMissingPlaceholders(): void;
    /**
     * @returns the deleted placeholders
     */
    protected _deletePlaceholders(tiles: Tile[]): PlaceholderTile[];
    validateLogicalGrid(): void;
    protected _setLogicalGrid(logicalGrid: LogicalGrid | string): void;
    setFocusedTile(tile: Tile): void;
    /** @see TileGridModel.selectable */
    setSelectable(selectable: boolean): void;
    protected _renderSelectable(): void;
    /** @see TileGridModel.multiSelect */
    setMultiSelect(multiSelect: boolean): void;
    /**
     * Selects the given tiles and deselects the previously selected ones.
     *
     * Tiles, that are currently invisible due to an active filter, are excluded and won't be selected.
     */
    selectTiles(tileOrIds: Tile | string | (Tile | string)[]): void;
    /** @see selectTiles */
    selectTile(tile: Tile): void;
    /**
     * Selects all tiles. As for every selection operation: only filtered tiles are considered.
     */
    selectAllTiles(): void;
    deselectTiles(tiles: Tile | Tile[]): void;
    deselectTile(tile: Tile): void;
    deselectAllTiles(): void;
    /**
     * Deselects every tile if all tiles are selected. Otherwise selects all tiles.
     */
    toggleSelection(): void;
    addTilesToSelection(tiles: Tile[]): void;
    addTileToSelection(tile: Tile): void;
    /**
     * @returns true if the tile is completely or partially visible in the first scrollable parent.
     */
    isTileInView(tile: Tile): boolean;
    protected _onTileMouseDown(event: JQuery.MouseDownEvent): boolean;
    protected _onTileClick(event: JQuery.ClickEvent): void;
    protected _triggerTileClick(tile: Tile, mouseButton: number, originalEvent: JQuery.ClickEvent): void;
    protected _onTileDoubleClick(event: JQuery.DoubleClickEvent): void;
    doTileAction(tile: Tile): void;
    protected _triggerTileAction(tile: Tile): void;
    setSelectionHandler(selectionHandler: TileGridSelectionHandler): void;
    protected _selectTileOnMouseDown(event: JQuery.MouseDownEvent): void;
    scrollTo(tile: Tile, options?: ScrollToOptions): void;
    /**
     * Brings the first selected tile into view by scrolling the first scrollable parent.
     */
    revealSelection(): void;
    /**
     * @param filter The filters to add.
     * @param applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.
     */
    addFilter(filter: FilterOrFunction<Tile> | FilterOrFunction<Tile>[], applyFilter?: boolean): void;
    /**
     * @param filter The filters to remove.
     * @param applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.
     */
    removeFilter(filter: FilterOrFunction<Tile> | FilterOrFunction<Tile>[], applyFilter?: boolean): void;
    /**
     * @param filter The new filters.
     * @param applyFilter Whether to apply the filters after modifying the filter list or not. Default is true.
     */
    setFilters(filters: FilterOrFunction<Tile> | FilterOrFunction<Tile>[], applyFilter?: boolean): void;
    filter(): void;
    protected _applyFilters(tiles: Tile[], fullReset?: boolean): FilterResult<Tile>;
    protected _createFilterSupport(): FilterSupport<Tile>;
    protected _createTextFilter(): TextFilter<Tile>;
    protected _updateTextFilterText(filter: Filter<Tile>, text: string): boolean;
    /** @see TileGridModel.textFilterEnabled */
    setTextFilterEnabled(textFilterEnabled: boolean): void;
    isTextFilterFieldVisible(): boolean;
    protected _renderTextFilterEnabled(): void;
    updateFilteredElements(result?: FilterResult<Tile>, opts?: UpdateFilteredElementsOptions): void;
    protected _updateEmpty(): void;
    setEmpty(empty: boolean): void;
    protected _renderEmpty(): void;
    /**
     * @returns the tiles which are accepted by the filter and therefore visible.
     */
    protected _filterTiles(tiles?: Tile[]): Tile[];
    findTileIndexAt(x: number, y: number, startIndex?: number, reverse?: boolean): number;
    /**
     * If the max range is used, the live list of filtered tiles is returned, because every tile has to be in the range.
     */
    findTilesInRange(viewRange: Range, filter?: Predicate<Tile>): Tile[];
    findTilesInRow(row: number): Tile[];
    /**
     * Executes the given function for each tile in a row.
     */
    eachTileInRow(row: number, func: (tile: Tile, index: number) => void): Tile[];
    /** @see TileGridModel.virtual */
    setVirtual(virtual: boolean): void;
    protected _setVirtual(virtual: boolean): void;
    protected _renderVirtual(): void;
    protected _updateVirtualScrollable(): void;
    calculateViewRangeSize(): number;
    /** @see TileGrid.viewRangeSize */
    setViewRangeSize(viewRangeSize: number, updateViewPort?: boolean): void;
    protected _heightForRow(row: number): number;
    /**
     * Used for virtual scrolling to calculate the view range size.
     * @returns the configured rowHeight + vgap / 2. Reason: the gaps are only between rows, the first and last row therefore only have 1 gap.
     */
    protected _minRowHeight(): number;
    rowCount(gridColumnCount?: number): number;
    /**
     * Calculates and renders the rows which should be visible in the current viewport based on scroll top.
     * @internal
     */
    _renderViewPort(): void;
    /**
     * Renders the rows visible in the viewport and removes the other rows
     */
    protected _renderViewRange(viewRange: Range): void;
    protected _renderTilesInRange(range: Range): void;
    /**
     * @returns the newly rendered tiles
     * @internal
     */
    _renderTileDelta(filterResult?: FilterResult<Tile>): Tile[];
    protected _removeTileByFilter(tile: Tile): void;
    protected _renderTileVisibleForFilter(tile: Tile): void;
    protected _renderTileOrder(prevTiles: Tile[]): void;
    protected _rowsRenderedInfo(): string;
    protected _removeTilesInRange(range: Range): void;
    protected _removeTilesInRow(row: number): void;
    rowHasRenderedTiles(row: number): boolean;
    ensureTileRendered(tile: Tile): void;
    protected _renderFiller(): void;
    protected _calculateFillerHeight(range: Range): number;
    /**
     * If virtual is false, the live list of filtered tiles is returned, because every tile has to be rendered.
     * If virtual is true, the rendered tiles are collected and returned.
     */
    renderedTiles(): Tile[];
}
export type TileGridMenuTypes = EnumObject<typeof TileGrid.MenuTypes>;
//# sourceMappingURL=TileGrid.d.ts.map