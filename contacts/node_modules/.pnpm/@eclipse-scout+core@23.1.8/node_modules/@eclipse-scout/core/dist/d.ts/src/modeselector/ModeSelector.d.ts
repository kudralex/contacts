import { EventHandler, InitModelOf, Mode, ModeSelectorEventMap, ModeSelectorModel, ObjectOrChildModel, PropertyChangeEvent, SwipeCallbackEvent, Widget } from '../index';
export declare class ModeSelector<TModeRef = any> extends Widget implements ModeSelectorModel<TModeRef> {
    model: ModeSelectorModel<TModeRef>;
    eventMap: ModeSelectorEventMap<TModeRef>;
    self: ModeSelector;
    modes: Mode<TModeRef>[];
    selectedMode: Mode<TModeRef>;
    $slider: JQuery;
    /**
     * When a new mode is set, the new one is marked as selected while the old one is deselected. This triggers the modePropertyChangeHandler.
     * In this case the handler must not react on the selection event. Otherwise, the value is first set to null (because the old is deselected) and then to the new value.
     * Setting a new mode should not trigger two change events.
     */
    protected _isModeChanging: boolean;
    protected _modePropertyChangeHandler: EventHandler<PropertyChangeEvent<any>>;
    constructor();
    protected _init(model: InitModelOf<this>): void;
    protected _render(): void;
    protected _renderProperties(): void;
    setModes(modes: ObjectOrChildModel<Mode<TModeRef>>[]): void;
    protected _setModes(modes: Mode<TModeRef>[]): void;
    protected _renderSlider(): void;
    protected _renderModes(): void;
    setSelectedMode(selectedMode: Mode<TModeRef>): void;
    protected _setSelectedMode(selectedMode: Mode<TModeRef>): void;
    protected _onModePropertyChange(event: PropertyChangeEvent<any, Mode<TModeRef>>): void;
    protected _updateMarkers(): void;
    /** @internal */
    _updateSlider(): void;
    protected _registerDragHandlers($mode: JQuery): void;
    protected _computeNewSelectedMode(e: SwipeCallbackEvent): Mode<TModeRef>;
    protected _findModeByPos(pos: number): Mode<TModeRef>;
    findModeById(id: string): Mode<TModeRef>;
    findModeByRef(ref: TModeRef): Mode<TModeRef>;
    selectModeById(id: string): void;
    selectModeByRef(ref: TModeRef): void;
}
//# sourceMappingURL=ModeSelector.d.ts.map