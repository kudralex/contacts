/// <reference types="jquery" />
import { DisplayParent, Event, EventHandler, EventListener, FileChooser, FileChooserController, Form, FormController, GlassPaneTarget, GroupBox, Icon, InitModelOf, KeyStrokeContext, Menu, MenuBar, MenuDestinations, MessageBox, MessageBoxController, ObjectOrChildModel, ObjectOrModel, OutlineContent, OutlineEventMap, OutlineMediator, OutlineModel, OutlineOverview, Page, PageModel, PropertyChangeEvent, Table, TableRow, TableRowDetail, TileOutlineOverview, Tree, Widget } from '../../index';
export declare class Outline extends Tree implements DisplayParent, OutlineModel {
    model: OutlineModel;
    eventMap: OutlineEventMap;
    self: Outline;
    nodes: Page[];
    selectedNodes: Page[];
    nodesMap: Record<string, Page>;
    compact: boolean;
    defaultDetailForm: Form;
    detailContent: OutlineContent | TableRowDetail;
    embedDetailContent: boolean;
    inBackground: boolean;
    iconId: string;
    iconVisible: boolean;
    mediator: OutlineMediator;
    navigateButtonsVisible: boolean;
    /** see NavigateUpButton.js */
    navigateUpInProgress: boolean;
    icon: Icon;
    outlineOverview: OutlineOverview;
    outlineOverviewVisible: boolean;
    title: string;
    titleVisible: boolean;
    titleMenuBar: MenuBar;
    nodeMenuBar: MenuBar;
    nodeMenuBarVisible: boolean;
    detailMenuBar: MenuBar;
    /** outline uses different level-paddings that normal trees */
    nodePaddingLevelHierarchyRow: number;
    detailMenuBarVisible: boolean;
    selectedViewTabs: Form[];
    views: Form[];
    dialogs: Form[];
    formController: FormController;
    messageBoxes: MessageBox[];
    messageBoxController: MessageBoxController;
    fileChoosers: FileChooser[];
    fileChooserController: FileChooserController;
    $title: JQuery;
    $titleText: JQuery;
    protected _detailContentDestroyHandler: EventHandler<Event<Widget>>;
    protected _detailMenusNodesSelectedHandler: EventListener & {
        outline: Outline;
        menuContainers: Widget[];
        addMenuContainer(container: Widget): any;
    };
    protected _detailMenusChangeHandler: EventHandler<PropertyChangeEvent<any, Widget>>;
    protected _detailMenusDestroyHandler: EventHandler<Event<Widget>>;
    protected _defaultDetailFormDestroyHandler: EventHandler<Event<Form>>;
    constructor();
    protected _init(model: InitModelOf<this>): void;
    /**
     * This function returns the outline mediator instance. When we're in an online Scout application we must
     * return a null instance here, because mediation is done server-side.
     */
    protected _createMediator(): OutlineMediator;
    insertNode(node: ObjectOrModel<Page>, parentNode?: Page): void;
    protected _createTreeNode(nodeModel?: PageModel): Page;
    protected _createKeyStrokeContext(): KeyStrokeContext;
    protected _filterMenus(argMenus: Menu[], destination: MenuDestinations, onlyVisible?: boolean, enableDisableKeyStrokes?: boolean): Menu[];
    protected _initTreeKeyStrokeContext(): void;
    protected _render(): void;
    protected _renderProperties(): void;
    protected _computeNodePaddingLeft(node: Page): number;
    protected _remove(): void;
    protected _renderTitle(): void;
    protected _removeTitle(): void;
    setIconVisible(iconVisible: boolean): void;
    setIconId(iconId: string): void;
    protected _updateIcon(): void;
    protected _removeIcon(): void;
    protected _renderTitleMenuBar(): void;
    protected _renderEnabled(): void;
    protected _initTreeNodeInternal(node: Page, parentNode: Page): void;
    protected _initDetailTableAndForm(node: Page): void;
    protected _initDetailTable(node: Page): void;
    protected _initDetailForm(node: Page): void;
    protected _createNavigateButtons(node: Page, parent: Table | GroupBox): Menu[];
    protected _getMenu(menus: Menu[], menuClass: new () => Menu): Menu;
    protected _hasMenu(menus: Menu[], menuClass: new () => Menu): boolean;
    protected _onTitleMouseDown(event: JQuery.MouseDownEvent): void;
    navigateToTop(): void;
    compactRootNode(): Page;
    handleInitialExpanded(): void;
    protected _onNodeDeleted(node: Page): void;
    selectNodes(nodes: Page | Page[], debounceSend?: boolean): void;
    protected _setSelectedNodes(nodes: Page[], debounceSend?: boolean): void;
    protected _nodesSelectedInternal(nodes: Page[]): void;
    protected _renderSelection(): void;
    protected _removeNodeSelection(node: Page): void;
    setDefaultDetailForm(defaultDetailForm: ObjectOrChildModel<Form>): void;
    protected _setDefaultDetailForm(defaultDetailForm: Form): void;
    protected _adaptDefaultDetailForm(form: Form): void;
    protected _onDefaultDetailFormDestroy(event: Event<Form>): void;
    setOutlineOverviewVisible(outlineOverviewVisible: boolean): void;
    protected _setOutlineOverviewVisible(outlineOverviewVisible: boolean): void;
    setOutlineOverview(outlineOverview: ObjectOrChildModel<OutlineOverview>): void;
    protected _setOutlineOverview(outlineOverview: ObjectOrChildModel<OutlineOverview>): void;
    protected _updateOutlineOverview(): void;
    protected _createOutlineOverview(): TileOutlineOverview;
    setNavigateButtonsVisible(navigateButtonsVisible: boolean): void;
    protected _setNavigateButtonsVisible(navigateButtonsVisible: boolean): void;
    protected _setNavigateButtonsVisibleForNode(node: Page, parentNode: Page): void;
    protected _appendNavigateButtonsForDetailForm(node: Page): void;
    protected _appendNavigateButtonsForDetailTable(node: Page): void;
    protected _removeNavigateButtonsForDetailForm(node: Page): void;
    protected _removeNavigateButtonsForDetailTable(node: Page): void;
    /**
     * @returns the selected row or null when no row is selected. When multiple rows are selected
     *    the first selected row is returned.
     */
    selectedRow(): TableRow;
    selectedNode(): Page;
    /**
     * Called by updateItemPath.
     */
    protected _isGroupingEnd(node: Page): boolean;
    /**
     * Disabled for outlines because outline may be resized.
     */
    protected _isTruncatedNodeTooltipEnabled(): boolean;
    setDetailFormVisibleByUi(node: Page, visible: boolean): void;
    validateFocus(): void;
    sendToBack(): void;
    bringToFront(): void;
    protected _renderInBackground(): void;
    protected _renderCompact(): void;
    protected _renderEmbedDetailContent(): void;
    protected _renderDetailContent(): void;
    nodeById(id: string): Page;
    nodesByIds(ids: string[]): Page[];
    protected _ensurePageLayout(page: Page): void;
    protected _removeDetailContent(): void;
    protected _postRenderViewRange(): void;
    setCompact(compact: boolean): void;
    setEmbedDetailContent(embedDetailContent: boolean): void;
    protected _setEmbedDetailContent(embedDetailContent: boolean): void;
    protected _onDetailContentDestroy(event: Event<Widget>): void;
    setDetailContent(content: OutlineContent | TableRowDetail): void;
    updateDetailContent(): void;
    protected _updateScrollTopAfterSelection(): void;
    protected _computeDetailContent(): OutlineContent | TableRowDetail;
    getRootContent(): Form | OutlineOverview;
    /**
     * Updates node and detail menubar.
     * Node menubar: Contains the table controls and right aligned menus.
     * Detail menubar: Contains the other menus.
     *
     * The menu items are gathered from various sources:
     * If the selected page has a detailForm, the menus are taken from there. Otherwise, the detail table and the parent detail table provide the menus.
     * The detail table contributes the empty space menus and the parent detail the single selection menus.
     *
     * The menus of the outline itself are not displayed. In fact the server won't deliver any.
     * One reason is that no menus are displayed in regular mode, so when switching to compact mode no menus would be available.
     * Another reason is that it would flicker because the menus are sent anew from the server every time a node gets selected because the menus are added to the outline and not to the node and are therefore not cached.
     */
    updateDetailMenus(): void;
    /**
     * Attaches a listener to the given menu container (which is the detail table or the detail table of the parent node)
     * in order to get dynamic menu changes and update the detailMenus on such a change event.
     * The impl. is lazy because it is only used in mobile mode.
     */
    protected _attachDetailMenusListener(menuContainer: Widget): void;
    setDetailMenus(detailMenus: Menu[]): void;
    protected _renderDetailMenuBarVisible(): void;
    protected _renderDetailMenuBar(): void;
    protected _removeDetailMenuBar(): void;
    setDetailMenuBarVisible(visible: boolean): void;
    setNodeMenus(nodeMenus: Menu[]): void;
    protected _renderNodeMenuBarVisible(): void;
    protected _renderNodeMenuBar(): void;
    protected _removeNodeMenuBar(): void;
    setNodeMenuBarVisible(visible: boolean): void;
    glassPaneTargets(element?: Widget): GlassPaneTarget[];
    protected _glassPaneTargets(element: Widget): GlassPaneTarget[];
    onGlassPaneMouseDown?(glassPaneOwner: Widget, $glassPane: JQuery): void;
    /**
     * === Method required for objects that act as 'displayParent' ===
     *
     * Returns true if this outline is active and not in background.
     */
    inFront(): boolean;
    /**
     * Called if outline acts as display parent.<p>
     * Returns true if outline is active, even if it is not rendered (e.g. when navigation is invisible)
     */
    acceptDialog?(dialog: Widget): boolean;
    /**
     * Called if outline acts as display parent.<p>
     * Returns true if outline is active, even if it is not rendered (e.g. when navigation is invisible)
     */
    acceptView?(view: Widget): boolean;
    activateCurrentPage(): void;
    activePage(): Page;
    protected _setViews(views: Form[]): void;
    /**
     * Overrides Tree (don't call parent)
     */
    protected _setMenus(menus: Menu[]): void;
    protected _triggerPageChanged(page: Page): void;
    protected _onLoadChildrenDone(activePage: Page): void;
    pageChanged(page: Page): void;
}
//# sourceMappingURL=Outline.d.ts.map